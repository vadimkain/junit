<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Конспект jUnit</title>
</head>
<style>
    body {
        max-width: 80%;
        min-height: 400vh;
        margin-left: 5%;
        text-align: justify;
        font-family: Arial, sans-serif;
    }

    article {
        /*background: wheat;*/
        border-left: solid 5px #24b8ff;
        padding-left: 5%;
        margin-top: 5%;
        margin-bottom: 5%;
    }

    pre {
        /*font-size: 15px;*/
        /*font-weight: bold;*/
        background: rgba(179, 194, 245, 0.18);
    }

    code {
        font-size: 15px;
        font-weight: bold;
        background: rgba(179, 194, 245, 0.18);
    }

    li {
        margin-top: 1%;
        margin-bottom: 1%;
    }
</style>
<body>
<article>
    <h1>JUnit 5. 17. Mockito. Mock</h1>
    <h2>Mock</h2>
    <p>
        Начнём с часто используемого - Mock. Во время использования наших моков мы будем сталкиваться и со stub'ами,
        и с fake'ами, и с dummy.
    </p>
    <p>
        Для начала нам нужно сделать <code>UserService</code> более реалистичным, т.е. добавить зависимость на
        <code>UserDao</code>. Создадим класс <code>UserDao</code> от которого будет зависеть <code>UserService</code>:
    </p>
    <pre>
    package com.kainv.dao;

    import lombok.SneakyThrows;

    import java.sql.Connection;
    import java.sql.DriverManager;

    public class UserDao {
        @SneakyThrows
        public boolean delete(Integer userId) {
            try (Connection connection = DriverManager.getConnection("url", "username", "password")) {
                return true;
            }
        }
    }
    </pre>
    <p>
        Возвращаемся в <code>UserService</code>, переопределяем конструктор и добавляем метод по удалению нашего
        пользователя т.е. в <code>UserService</code> приходит метод для удаления пользователя и он просто перенаправляет
        его на <code>UserDao</code> поэтому пишем:
    </p>
    <pre>
    package com.kainv.service;

    import com.kainv.dao.UserDao;
    import com.kainv.dto.User;

    import java.util.*;

    import static java.util.function.Function.identity;
    import static java.util.stream.Collectors.toMap;

    public class UserService {

        private final List&lt;User> users = new ArrayList&lt;>();
        private final UserDao userDao;

        public UserService(UserDao userDao) {
            this.userDao = userDao;
        }

        public boolean delete(Integer userId) {
            return userDao.delete(userId);
        }

        public List&lt;User> getAll() {
            return users;
        }

        public void add(User... users) {
            this.users.addAll(Arrays.asList(users));
        }

        public Optional&lt;User> login(String username, String password) {
            if (username == null || password == null) {
                throw new IllegalArgumentException("username or password is null");
            }
            return users.stream()
                    .filter(user -> user.getUsername().equals(username))
                    .filter(user -> user.getPassword().equals(password))
                    .findFirst();
        }

        public Map&lt;Integer, User> getAllConvertedById() {
            return users.stream().collect(toMap(User::getId, identity()));
        }
    }
    </pre>
    <p>
        Теперь видим, что если напишем тест на метод <code>delete()</code>, то это будет уже <b>интеграционный</b>
        тест. Потому что мы проверяем не только логику метода нашего <code>delete()</code> у <code>UserService</code>,
        но и логику работы нашего метода <code>delete()</code> у <code>UserDao</code>. Т.е. два совершенно разных
        класса, следственно это интеграционный тест как <code>UserService</code> дружит с <code>UserDao</code>.
    </p>
    <h3>Напишем тест на метод delete() в UserService</h3>
    <p>
        Переходим в <code>UserServiceTest</code> и пишем тест. Предварительно нужно закоментировать
        <code>ThrowableExtension.class</code> в <code>@ExtendWith({})</code> потому что он ловит все наши исключения
        и говорит что тесты прошли.
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void shouldDeleteExistedUser() {
        userService.add(VADIM);

        boolean deleteResult = userService.delete(VADIM.getId());

        assertThat(deleteResult).isTrue();
    }
    </pre>
    <p>
        Если запустим, то тесты упадут потому что зайдя в <code>UserDao</code> и вызвав метод <code>delete()</code>
        мы не смогли подключиться к БД. Следственно, это уже интеграционный тест. Следственно, мы должны использовать
        <b>Mockito</b>.
    </p>
    <p>
        Для этого нам нужно проинициализировать наш <code>UserService</code>. Не будем использовать наш DI-механизм.
        Во-первых добавляем <code>UserDao</code> как поле в нашем <code>UserServiceTest</code> классе:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        private UserDao userDao;
    </pre>
    <p>
        И теперь его тоже надо проинициализоровать и передать в <code>UserService</code> в методе <code>prepare()</code>.
        Мы не можем напрямую передать <code>this.userDao = new UserDao();</code>. Для этого нам нужен какой-то
        mock-объект который мы в дальнейшем будем программировать. Мы не должны реальные методы вызывать у
        <code>UserDao</code> поэтому используем метод <code>Mockito.mock()</code>, который создаёт прокси-объект
        с таким же классом который мы передали в него в качестве параметра:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @BeforeEach
    void prepare() {
        System.out.println("Before each: " + this);
        this.userDao = Mockito.mock(UserDao.class);
        this.userService = new UserService(userDao);
    }
    </pre>
    <p>
        Теперь, если запустим тест, то реальный метод не вызовется. Но тесты и не выполнятся.
    </p>
    <img src="ju-17-1.png" alt="ju-17-1" width="60%">
    <p>
        Сначала разберёмся почему вернулся false, а во вторых, что это за Mock объект.
    </p>
    <h3>Создадим mock-объект вручную</h3>
    <pre>
    package com.kainv.junit.dao;

    import com.kainv.dao.UserDao;

    public class UserDaoMock extends UserDao {
        @Override
        public boolean delete(Integer userId) {
            return false;
        }
    }
    </pre>
    <p>
        Мы можем использовать его вместо реального <code>UserDao</code> потому что он наследуется от него и
        переопределяет
        все его методы. Возвращаются, как правило, какие-то дефолтные значения. Для примитивных типов это обычные
        дефолтные значения (для boolean - false, для целочисленных - 0 и т.д.), для объектов сложных это null, для
        коллекций это обычные пустые коллекции.
    </p>
    <p>
        Т.к. <code>UserDaoMock</code> наследуется от <code>UserDao</code>, следственно мы можем его использовать везде
        где используется <code>UserDao</code>. Но тут опять видим ограничения потому что мы не можем сделать
        <code>final class UserDao</code> потому что тогда не сможем наследоваться от него.
    </p>
    <p>
        Мы опять приходим к двум вариантам создания mock-ов: это динамическое прокси и наследование как это делает
        Mockito и Spring. Наш класс <b>не должен быть</b> <code>final</code> иначе будет исключение.
    </p>
    <h3>Возвращаемся в UserServiceTest</h3>
    <p>
        Мы добавили <code>UserDao</code>, но теперь хотим его как-то запрограммировать чтобы при удалении именно в
        <code>userService.delete(VADIM.getId());</code>, именно наш <code>userDao</code> должен вернуть true или
        false. Мы должны научить его делать потому что по умолчанию он возвращает дефолтное значение false.
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void shouldDeleteExistedUser() {
        userService.add(VADIM);

        boolean deleteResult = userService.delete(VADIM.getId());

        assertThat(deleteResult).isTrue();
    }
    </pre>
    <p>
        Для этого опять же воспользуемся Mockito и пишем:
    </p>
    <pre>
        @Test
        void shouldDeleteExistedUser() {
            userService.add(VADIM);

    //        STUB: верни true, когда у userDao вызовем метод delete и передадим туда VADIM.getId()
            Mockito.doReturn(true).when(userDao).delete(VADIM.getId());

            boolean deleteResult = userService.delete(VADIM.getId());

            assertThat(deleteResult).isTrue();
        }
    </pre>
    <p>
        Мы создали <b>Stub</b> для ответа на вызов метода mock'ом. Т.е. говорим: верни true, когда у userDao вызовем
        метод delete и передадим туда VADIM.getId(). В данном случае нас <b>интересует</b> этот id'шник следственно это
        фейковый идшник, но если он нас <b>не интересует</b>, то мы на любой переданный ид в метод <code>delete()</code>
        в <code>UserDao</code> хотим вернуть true. Тогда мы используем <b>dummy</b>-объект. Т.е. у мокито есть куча
        методов типа <code>any()</code>:
    </p>
    <b>UserServiceTest</b>
    <pre>
        @Test
        void shouldDeleteExistedUser() {
            userService.add(VADIM);

    //        STUB: верни true, когда у userDao вызовем метод delete и передадим туда VADIM.getId()
            Mockito.doReturn(true).when(userDao).delete(VADIM.getId());

    //        Если никакой ид не интересует
    //        Mockito.doReturn(true).when(userDao).delete(Mockito.any());

            boolean deleteResult = userService.delete(VADIM.getId());

            assertThat(deleteResult).isTrue();
        }

    </pre>
    <p>
        Запустим и проверим что получится:
    </p>
    <img src="ju-17-2.png" alt="ju-17-2" width="60%">
    <p>
        В этот раз вернул уже true.
    </p>
    <h2>Как это работает</h2>
    <p>
        Как мы научили <code>UserDao</code> возвращать результат true, когда передаём какой-то определенный идшник?
    </p>
    <p>
        Всё очень просто: напишем что-то вроде ассоциативного массива:
    </p>
    <pre>
    package com.kainv.junit.dao;

    import com.kainv.dao.UserDao;

    import java.util.HashMap;
    import java.util.Map;

    public class UserDaoMock extends UserDao {

        // Ключ Integer потому что аргумент типа Integer и значение Boolean потому что метод возвращает boolean
        private Map&lt;Integer, Boolean> answers = new HashMap&lt;>();
        @Override
        public boolean delete(Integer userId) {
            return answers.getOrDefault(userId, false);
        }
    }

    </pre>
    <p>
        Теперь, каждый раз когда мы обучаем наш <code>UserDaoMock</code> - мы просто у нашего <code>answers</code>
        берём результат по ключу. Теперь, каждый раз когда обучаем наш <code>UserDaoMock</code> - мы просто берём
        у нашего <code>answers</code> результат по ключу иначе возвращаем false. Для того чтобы обучить этот
        <code>answers</code> - мы используем утилитный класс мокито и добавляем туда значения. Например, по id 1
        верни true и т.д..
    </p>
    <p>
        Этот метод не универсальный потому что у нас могут быть другие типы данных и несколько параметров. Следственно,
        это все уже решено за нас и у нас есть специальный класс как <code>Answer</code> (<i>stubbing</i> - пакет
        в мокито который занимается созданием <b>stub</b>'ов). <code>Answer1</code>, <code>Answer2</code> и т.д.
        говорит о кол-ве аргументов в методе.
    </p>
    <pre>
    package com.kainv.junit.dao;

    import com.kainv.dao.UserDao;
    import org.mockito.stubbing.Answer1;

    import java.util.HashMap;
    import java.util.Map;

    public class UserDaoMock extends UserDao {

        // Ключ Integer потому что аргумент типа Integer и значение Boolean потому что метод возвращает boolean
        private Map&lt;Integer, Boolean> answers = new HashMap&lt;>();
        private Answer1&lt;Integer, Boolean> answer1;
        @Override
        public boolean delete(Integer userId) {
            return answers.getOrDefault(userId, false);
        }
    }
    </pre>
    <h2>Возвращаемся в UserServiceTest</h2>
    <p>
        Если передадим в <code>userService.delete(2)</code>, то тест упадёт потому что вернёт единичку:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        void shouldDeleteExistedUser() {
            userService.add(VADIM);

    //        STUB: верни true, когда у userDao вызовем метод delete и передадим туда VADIM.getId()
            Mockito.doReturn(true).when(userDao).delete(VADIM.getId());

    //        Если никакой ид не интересует
    //        Mockito.doReturn(true).when(userDao).delete(Mockito.any());

            boolean deleteResult = userService.delete(2);

            assertThat(deleteResult).isTrue();
        }
    </pre>
    <img src="ju-17-3.png" alt="ju-17-3" width="60%">
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        void shouldDeleteExistedUser() {
            userService.add(VADIM);

    //        STUB: верни true, когда у userDao вызовем метод delete и передадим туда VADIM.getId()
    //        Mockito.doReturn(true).when(userDao).delete(VADIM.getId());

    //        Если никакой ид не интересует
            Mockito.doReturn(true).when(userDao).delete(Mockito.any());

            boolean deleteResult = userService.delete(2);

            assertThat(deleteResult).isTrue();
        }
    </pre>
    <img src="ju-17-4.png" alt="ju-17-4" width="60%">
    <p>
        В этот раз тест пройден потому что нас не интересует идентификатор, мы в любом случае возвращаем true. Таким
        образом можем программировать <code>Mockito.doReturn()</code> и возвращать любое значение которое только
        захотим.
    </p>
    <h3>Второй вариант программирования</h3>
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        void shouldDeleteExistedUser() {
            userService.add(VADIM);

    //        STUB: верни true, когда у userDao вызовем метод delete и передадим туда VADIM.getId()
    //        Mockito.doReturn(true).when(userDao).delete(VADIM.getId());

    //        Если никакой ид не интересует
    //        Mockito.doReturn(true).when(userDao).delete(Mockito.any());

            Mockito.when(userDao.delete(VADIM.getId())).thenReturn(true);

            boolean deleteResult = userService.delete(2);

            assertThat(deleteResult).isTrue();
        }
    </pre>
    <p>
        Этот вариант тоже работает, но не для всех случаев. Первый вариант является предпочтительнее потому что он
        является универсальным. Второй вариант позволяет последовательно возвращать значения если будем вызывать у
        одного и того же mock'а несколько раз метод <code>delete()</code> чтобы он возвращал сначала true, а потом
        false:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        void shouldDeleteExistedUser() {
            userService.add(VADIM);

    //        STUB: верни true, когда у userDao вызовем метод delete и передадим туда VADIM.getId()
    //        Mockito.doReturn(true).when(userDao).delete(VADIM.getId());

    //        Если никакой ид не интересует
    //        Mockito.doReturn(true).when(userDao).delete(Mockito.any());

            Mockito.when(userDao.delete(VADIM.getId()))
                    .thenReturn(true)
                    .thenReturn(false);

            boolean deleteResult = userService.delete(VADIM.getId());
            System.out.println(userService.delete(VADIM.getId()));
            System.out.println(userService.delete(VADIM.getId()));

            assertThat(deleteResult).isTrue();
        }
    </pre>

</article>
<article>
    <h1>Junit 5. 16. Mockito. Test Doubles</h1>
    <p>
        На предыдущих занятиях мы писали наши тесты на основании <code>UserService</code>. Т.е. писали именно unit-тесты
        проверяя лишь какой-то метод в нашем <code>UserService</code>. Но мы пошли очень простым путём, мы всего лишь
        создали список наших пользователей и у нашего <code>UserService</code> не было зависимости на другие сервисы
        либо, к примеру, <code>UserDao</code> который бы обращался в базу данных и получал бы значения. В таком случае
        у нас уже был бы не юнит тест, а интеграционный тест. Потому что тестируя к примеру метод <code>add()</code>
        в <code>UserService</code> - мы бы обращались ещё к <code>UserDao</code> который выполнял бы метод
        <code>insert()</code> в базу данных.
    </p>
    <p>
        На практике такие варианты встречаются чаще всего. Поэтому у нас происходит следующее:
    </p>
    <img src="ju-16-1.png" alt="ju-16-1" width="40%">
    <p>
        Наш <code>UserService</code> будет обращаться к <code>UserDao</code> или другим сервисам и следовательно,
        для того чтобы написать наши юнит тесты, а не интеграционные тесты - мы должны каким-то образом не
        взаимодействовать с реальными объектами других сервисов и Dao потому что хотим протестировать только функционал
        нашего <code>UserService</code>. Именно здесь на помощь приходит фреймворк <b>Mockito</b>, который позволяет
        нам делать что-то вроде заглушек на зависимые классы. Т.е. на другие сервисы и классы чтобы не вызывать
        реальные эти объекты.
    </p>
    <p>
        Для того чтобы лучше понять Mockito, нам необходимо разобраться с подставными объектами, что они из себя
        представляют. Следственно, у нас есть специальное определение, которое называется <b>Test Doubles</b>,
        которое можно переводить как дублёры. Т.е. какой-то второй объект, который пришел нам на замену настоящего.
    </p>
    <img src="ju-16-2.png" alt="ju-16-2" width="30%">
    <ol>
        <li>
            <p>
                <b>Dummy</b> - это объекты, которые не используются во время тестирования. Нужны только для заполнения
                параметров методов.
            </p>
            <p>
                Например, когда тестируем наш метод <code>login()</code>, нас может не интересовать какие мы username
                ввели, какие пароли, чтобы пройти аутентификацию. Следственно, нам всё равно что это за объекты будут.
                Мы их создаём только для того чтобы мы могли вызвать наш метод <code>login()</code> как это делали
                в наших тестах.
            </p>
            <img src="ju-16-3.png" alt="ju-16-3" width="60%">
            <p>
                Как в этом коде - нас не интересовал какой username, мы передали выдуманный объект. Mockito
                предоставляет
                более удобный функционал для этого.
            </p>
        </li>
        <li>
            <p>
                <b>Fake</b> - объекты с работающим функционалом, но не подходящим для production. Например, запуск
                in-memory базы данных для тестирования DAO слоя.
            </p>
            <p>
                Т.е. у нас есть реальная база данных, но для тестирования мы не хотим поднимать реальную, мы можем
                понять фейковую БД и на ней проверять тесты.
            </p>
            <p>
                В нашем случае мы создавали Вадимов и Петь для того чтобы к примеру добавить нашего пользователя
                в систему (<code>userService.add(VADIM);</code>).
            </p>
        </li>
        <li>
            <p>
                <b>Stub</b> - объекты, которые используются <b>mocks</b> и <b>spies</b> для ответа (Answer) на вызовы
                методов во время тестов.
            </p>
            <p>
                Это всего лишь объект, который должен вернуться если мы у наших других объектов (mocks & spies) вызовем
                какой-то метод с определенными параметрами.
            </p>
        </li>
        <li>
            <p>
                <b>Mock</b> - запрограммированные объекты, возвращающие ожидаемый результат (<b>stubs</b>) на вызов
                определенных методов.
            </p>
            <p>
                Т.е. по сути у нас есть к примеру <code>UserService</code>, но мы подставляем какой-то mock-объект
                <code>UserService</code>'а и мы можем его использовать везде где его использовали
                <code>UserService</code>,
                но как он будет функционировать. Т.е. как будет реагировать на вызов метода логина, добавления и прочее
                мы будем сами программировать используя какие-то параметры на вход наших методов и stub'ы, для того
                чтобы вернуть какие-то значения из наших методов.
            </p>
        </li>
        <li>
            <p>
                <b>Spy</b> - proxy для реальных объектов, которые ведут себя точно также, но могут быть
                запрограммированы
                как <b>mocks</b>.
            </p>
            <p>
                Т.е. по сути создаём <b>spy</b> на основании нашего реального <code>UserService</code>'а и до тех пор,
                пока мы не начали его программировать, как-то настраивать его поведения как это делали в mock'ах (т.е.
                на вызов определенного метода с определенными параметрами) - мы должны вернуть <b>stubs</b> не
                вызывая настоящий метод.
            </p>
        </li>
    </ol>
    <h2>Подключим библиотеку Mockito</h2>
    <b>pom.xml</b>
    <pre>
        &lt;dependency>
            &lt;groupId>org.mockito&lt;/groupId>
            &lt;artifactId>mockito-core&lt;/artifactId>
            &lt;version>3.9.0&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
</article>
<article>
    <h1>JUnit 5. 15. Extension Model. Практика</h1>
    <h2>Начнём с модели Test life cycle callbacks</h2>
    <p>
        Является самой сложной. Callback'и - это всего лишь интерфейсы реализовав которые мы можем внедриться в любой
        из этапов жизненного цикла теста. А именно, если посмотрим более детально на эти callback'и, то получается, у
        нас есть шесть разных callback'ов:
    </p>
    <img src="ju-15-1.png" alt="ju-15-1" width="60%">
    <p>
        В callback'ах реализуем один единственный метод и он будет вызываться у нас если мы его переопределим и добавим
        через аннотацию <code>@ExtendWith({})</code> нашего тестового класса.
    </p>
    <p>
        Создадим свой extension, только сначала папку <i>paramresolver</i> переименуем в <i>extension</i> и создадим
        какой-нибудь <code>GlobalExtension</code>. Для того чтобы внедриться в один из шагов жизненного цикла теста,
        мы всего лишь должны переопределить соответствующие интерфейсы:
    </p>
    <pre>
    package com.kainv.junit.extension;

    import org.junit.jupiter.api.extension.BeforeAllCallback;
    import org.junit.jupiter.api.extension.ExtensionContext;

    public class GlobalExtension implements BeforeAllCallback {
        @Override
        public void beforeAll(ExtensionContext extensionContext) throws Exception {

        }
    }
    </pre>
    <p>
        Получаем объект типа <code>ExtensionContext</code>, следственно мы можем получить всё что захотим. В нашем
        случае всего лишь пометим, что это <i>before all callback</i>:
    </p>
    <b>GlobalExtension.java</b>
    <pre>
    @Override
    public void beforeAll(ExtensionContext extensionContext) throws Exception {
        System.out.println("before all callback");
    }
    </pre>
    <p>
        Более того, можем продолжить реализовывать интерфейсы и одним Extension'ом нашим можем реализовать несколько
        таких интерфейсов и внедриться сразу же одним классом на любые из жизненных циклов тестов. Более того, можем
        реализовать совершенно любые Extension'ы которые только захотим:
    </p>
    <pre>
    package com.kainv.junit.extension;

    import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
    import org.junit.jupiter.api.extension.BeforeAllCallback;
    import org.junit.jupiter.api.extension.ExtensionContext;

    public class GlobalExtension implements BeforeAllCallback, AfterTestExecutionCallback {
        @Override
        public void beforeAll(ExtensionContext extensionContext) throws Exception {
            System.out.println("before all callback");
        }

        @Override
        public void afterTestExecution(ExtensionContext extensionContext) throws Exception {
            System.out.println("after test execution");
        }
    }
    </pre>
    <p>
        Теперь, для того чтобы подключить наш Extension, нам нужно в <code>@ExtendWith({})</code> подключить наш
        класс-Execution:
    </p>
    <pre>
    @ExtendWith({
            UserServiceParamResolver.class,
            GlobalExtension.class
    })
    public class UserServiceTest {
    </pre>
    <p>
        Если выполним запуск тестов, то увидим всё то, что мы реализовали в <code>GlobalExtension</code>.
    </p>
    <p>
        В основном подобные Extension'ы мы используем уже существующими. Свои пишутся довольно редко, только когда хотим
        предоставить какой-то функционал или общий базовый класс для всех наших тестов. Ведь мы можем создать свой
        тестовый базовый класс, например в директории <i>junit</i> создаётся какой-то <code>abstract class
        TestBase</code>,
        который в себе ничего не содержит, но может реализовать какие-то Extension'ы:
    </p>
    <pre>
    package com.kainv.junit;

    import com.kainv.junit.extension.GlobalExtension;
    import org.junit.jupiter.api.extension.ExtendWith;

    @ExtendWith({
            GlobalExtension.class
    })
    public abstract class TestBase {
    }
    </pre>
    <p>
        Естественно, если будем наследовать наш <code>TestBase</code>, то все Extension'ы так же наследуются нашими
        потомками:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @ExtendWith({
            UserServiceParamResolver.class,
    //        GlobalExtension.class
    })
    public class UserServiceTest extends TestBase {
    </pre>
    <h2>Test instance post-processing</h2>
    <p>
        Создадим ещё один Extension, который будет <code>PostProcessingExtension</code>:
    </p>
    <p>
        <code>Object o</code> - это мы получаем объект нашего класса. Поменяели на <code>Object testInstance</code>
        для лучшей читабельности.
    </p>
    <p>
        Именно этот Extension <b>используется Spring'ом</b> для внедрения зависимостей. Потому что как раз таки
        в этом callback'e мы приходим в точку, когда только-только создался объект нашего тестового класса и в нем есть
        поля от которых хотим зависеть. Следовательно, можем спокойно взять <code>testInstance</code>, взять у него
        все поля и далее пройтись по каждому из них и если поле (<code>declaredField</code>) имеет аннотацию
        <code>@Getter</code> (<b>плохой случай</b> потому что геттер аннотация недоступна в runtime), то внедряем
        в это поле какие-то значения:
    </p>
    <pre>
    package com.kainv.junit.extension;

    import com.kainv.service.UserService;
    import lombok.Getter;
    import org.junit.jupiter.api.extension.ExtensionContext;
    import org.junit.jupiter.api.extension.TestInstancePostProcessor;

    import java.lang.reflect.Field;

    public class PostProcessingExtension implements TestInstancePostProcessor {
        @Override
        public void postProcessTestInstance(Object testInstance, ExtensionContext extensionContext) throws Exception {
            System.out.println("post processing extension");
            Field[] declaredFields = testInstance.getClass().getDeclaredFields();
            for (Field declaredField : declaredFields) {
                if (declaredField.isAnnotationPresent(Getter.class)) {
                    declaredField.set(testInstance, new UserService());
                }
            }
        }
    }

    </pre>
    <p>
        Таким образом и поступает Spring. Далее в нашем <code>UserServiceTest</code> в аннотации
        <code>@ExtendWith({})</code> внедряем наш Extension:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @ExtendWith({
            UserServiceParamResolver.class,
            PostProcessingExtension.class
    //        GlobalExtension.class
    })
    public class UserServiceTest extends TestBase {
    </pre>
    <p>
        Запускаем и видим в консоли, что post processing для нашего <code>UserServiceTest</code> класса выдался один
        раз.
        Далее, он выдался только для внутреннего класса потому что наш <code>UserServiceTest</code> в
        <code>@TestInstance(Lifecycle.PER_CLASS)</code>. Следственно, один раз создался <code>UserService</code> для
        всех наших методов внутри нашего <code>UserServiceTest</code>. Далее, создаётся каждый раз новый инстанс для
        нашего внутреннего класса.
    </p>
    <img src="ju-15-2.png" alt="ju-15-2" width="60%">
    <h2>Conditional test execution</h2>
    <p>
        Так же создаём свой <code>ConditionalExtension</code> и реализуем интерфейс <code>ExecutionCondition</code>,
        а так же его один единственный метод:
    </p>
    <pre>
    package com.kainv.junit.extension;

    import org.junit.jupiter.api.extension.ConditionEvaluationResult;
    import org.junit.jupiter.api.extension.ExecutionCondition;
    import org.junit.jupiter.api.extension.ExtensionContext;

    public class ConditionalExtension implements ExecutionCondition {
        @Override
        public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext extensionContext) {
            return null;
        }
    }
    </pre>
    <p>
        Теперь у нас есть доступ к <code>ExtensionContext</code> и мы можем в этом методе определять, стоит ли вызывать
        наш тест или нет. Например:
    </p>
    <pre>
    package com.kainv.junit.extension;

    import org.junit.jupiter.api.extension.ConditionEvaluationResult;
    import org.junit.jupiter.api.extension.ExecutionCondition;
    import org.junit.jupiter.api.extension.ExtensionContext;

    public class ConditionalExtension implements ExecutionCondition {
        @Override
        public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext extensionContext) {
    //        Если передали property "skip" и не равна null, то запускаем отключаем тест. В противном случае - выполняем.
            return System.getProperty("skip") != null
                    ? ConditionEvaluationResult.disabled("test is skipped")
                    : ConditionEvaluationResult.enabled("enabled by default");
        }
    }
    </pre>
    <p>
        Если внедрим <code>ConditionalExtension</code> в наш <code>UserServiceTest</code>, и в <b>VM options</b>
        передадим флаг <code>-Dskip</code>, то все наши тесты не запустятся в классе, в котором внедрили зависимость.
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @ExtendWith({
            UserServiceParamResolver.class,
            PostProcessingExtension.class,
            ConditionalExtension.class
    //        GlobalExtension.class
    })
    public class UserServiceTest extends TestBase {
    </pre>
    <img src="ju-15-3.png" alt="ju-15-3" width="60%">
    <br>
    <img src="ju-15-4.png" alt="ju-15-4" width="60%">
    <h2>Parameter resolution - уже проходили</h2>
    <h2>Exception handling</h2>
    <p>
        Т.е. когда обрабатываем какие-то exception'ы которые у нас получились из наших тестовых методов. Напишем
        класс <code>ThrowableException</code> и реализуем соответствующий интерфейс:
    </p>
    <pre>
    package com.kainv.junit.extension;

    import org.junit.jupiter.api.extension.ExtensionContext;
    import org.junit.jupiter.api.extension.TestExecutionExceptionHandler;

    import java.io.EOFException;

    public class ThrowableExtension implements TestExecutionExceptionHandler {
        @Override
        public void handleTestExecutionException(ExtensionContext extensionContext, Throwable throwable) throws Throwable {
    //        Если наш throwable является IOException, то пробрасываем его дальше
            if (throwable instanceof IOException) {
                throw throwable;
            }
        }
    }
    </pre>
    <p>
        В <code>UserServiceTest</code>, в методе <code>usersEmptyIfNoUserAdded</code> вызовем исключение:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    @Order(1)
    @DisplayName("users will be empty if no user added")
    void usersEmptyIfNoUserAdded() throws IOException {
        if (true) {
            throw new IOException();
        }

        System.out.println("Test 1: " + this);

        List&lt;User> users = userService.getAll();

        MatcherAssert.assertThat(users, IsEmptyCollection.empty());
        assertTrue(users.isEmpty(), () -> "User list should be empty");
    }
    </pre>
    <img src="ju-15-5.png" alt="ju-15-5" width="60%">
    <br>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    @Order(1)
    @DisplayName("users will be empty if no user added")
    void usersEmptyIfNoUserAdded() throws IOException {
        if (true) {
            throw new RuntimeException();
        }

        System.out.println("Test 1: " + this);

        List&lt;User> users = userService.getAll();

        MatcherAssert.assertThat(users, IsEmptyCollection.empty());
        assertTrue(users.isEmpty(), () -> "User list should be empty");
    }
    </pre>
    <img src="ju-15-6.png" alt="ju-15-6" width="60%">
</article>
<article>
    <h1>JUnit 5. 14. Extension Model. Теория</h1>
    <h2>Что такое extension model в JUnit 5?</h2>
    <p>
        Extension Model в JUnit 5 - это новая функциональность, которая позволяет расширять функциональность фреймворка
        JUnit 5. Он предоставляет возможность программистам настраивать поведение JUnit 5 во время выполнения тестов,
        добавляя новые функциональные возможности, такие как логирование, запуск тестов в параллельном режиме,
        подключение к базам данных и многое другое.
    </p>
    <p>
        Расширения могут быть написаны как отдельные классы, реализующие интерфейс Extension, так и использовать
        предоставляемые фреймворком аннотации, такие как <code>@BeforeEachCallback</code> или
        <code>@AfterAllCallback</code>. Расширения могут быть добавлены как к классам тестов, так и к тестовым методам,
        что дает большую гибкость в управлении поведением тестов.
    </p>
    <p>
        Extension Model позволяет программистам создавать свои собственные расширения или использовать существующие,
        доступные из различных источников, таких как библиотеки, плагины или фреймворки. Расширения могут быть объявлены
        в файле META-INF/services/org.junit.jupiter.api.extension.Extension, который будет автоматически обнаружен и
        загружен при запуске тестов.
    </p>
    <h2>Т.е., Extension Model это некий прокси-паттерн?</h2>
    <p>
        Extension Model в JUnit 5 можно рассматривать как реализацию паттерна расширяемости. Это позволяет настраивать и
        расширять поведение фреймворка JUnit 5, не изменяя его исходный код.
        <br><br>
        Внутри Extension Model используется механизм вызова методов обратного вызова (callback), который позволяет
        расширениям реагировать на определенные события, связанные с выполнением тестов. Например, при запуске теста
        может быть вызван метод обратного вызова "beforeEach", который позволяет расширению выполнить какую-то
        дополнительную подготовку перед запуском теста.
        <br><br>
        Таким образом, можно сказать, что Extension Model - это не конкретный паттерн, а набор функциональности,
        реализующий паттерны расширяемости и обратных вызовов для настройки поведения фреймворка JUnit 5.
    </p>
    <h2>Расскажи про паттерн расширяемости</h2>
    <p>
        Паттерн расширяемости (Extensibility Pattern) - это паттерн проектирования, который позволяет расширять
        функциональность программного продукта без необходимости изменения его исходного кода.
        <br><br>
        Паттерн расширяемости широко используется в различных программных продуктах и фреймворках. Он позволяет
        добавлять новые возможности и функции в систему без необходимости изменения ее основной функциональности. Это
        делает систему более гибкой и удобной для использования, так как пользователи могут настраивать ее под свои
        потребности и задачи.
        <br><br>
        Для реализации паттерна расширяемости используются различные механизмы, такие как плагины, расширения, модули и
        т.д. Основная идея заключается в том, чтобы разбить систему на модули, которые могут быть расширены или заменены
        при необходимости.
        <br><br>
        Примером фреймворка, который использует паттерн расширяемости, является Spring Framework. В Spring существует
        множество расширений (Extension Points), которые позволяют настраивать и расширять поведение фреймворка. Это
        позволяет разработчикам создавать более гибкие и масштабируемые приложения, которые могут легко адаптироваться к
        изменяющимся требованиям бизнеса.
        <br><br>
        В JUnit 5 паттерн расширяемости реализуется через Extension Model, который позволяет расширять функциональность
        фреймворка и настраивать поведение тестов во время их выполнения. Расширения могут быть написаны для решения
        различных задач, таких как логирование, запуск тестов в параллельном режиме, подключение к базам данных и т.д.
    </p>
    <h2>Аннотация @ExtendWith({})</h2>
    <p>
        Мы её уже использовали ранее на DI механизме, когда создавали свои параметры-resolver'ы и сейчас более подробно
        поговорим про это.
    </p>
    <img src="ju-14-1.png" alt="ju-14-1" width="30%">
    <p>
        Extension Model представляет собой пять основных типов:
    </p>
    <ol>
        <li>
            <b>Test life cycle callbacks</b> - т.е. мы можем внедриться в любую часть жизненного цикла наших тестов и
            добавить какой-то функционал в любой из частей нашего жизненного цикла. Поэтому, мы благодаря специальным
            callback'ам (<i>это всего лишь интерфейсы</i>) мы можем внедриться в любой из шагов жизненного цикла теста.
        </li>
        <li>
            <b>Test instance post-processing *</b> - такая возможность позволяет нам что-то подкрутить после создания
            объекта нашего тестового класса. Т.е. мы знаем, что по умолчанию каждый раз создаётся новый объект класса
            <code>UserServiceTest</code> и вызывается собственно наш тест. Так вот именно этот callback позволяет
            нам добавить какую-ту свою функциональность сразу же после создания этого объекта. Как раз таки спринг
            использует такую возможность, для того чтобы внедрить свои зависимости в этот объект.
        </li>
        <li>
            <b>Conditional test execution</b> - такая возможность extension model'и позволяет нам какие-то условия на
            выполнения либо невыполнения тестов. Например, можем какие-то тесты отключить если environment variables
            будет qa или что-то вроде этого. Т.е. у нас есть доступ практически ко всему и мы можем на основании этих
            данных принимать решение о выполнении или невыполнении каких-то тестов.
        </li>
        <li>
            <b>Parameter resolution</b> - проходили на теме по DI. Т.е. можем без проблем создать свои
            параметры-resolution'ы, для того чтобы внедрять свои зависимости в любой из методов жизненного цикла
            наших тестов.
        </li>
        <li>
            <b>Exception handling</b> - т.е. можем отлавливать исключения, которые пробрасываются в наших тестах и
            так же с ними что-то подкрутить, что-то сделать.
        </li>
    </ol>
    <h2>Вспомним как делать parameter resolution</h2>
    <p>
        Т.е. мы добавляем какой-то функционал к нашему тесту через <code>@ExtendWith</code>. Т.е. добавляем какое-то
        поведение и в этот раз уже можем передавать массив таких <code>Extension'ов</code>. Главная задача - это
        всего лишь реализовать интерфейс <code>Extension</code>.
    </p>
    <h3>Что это за интерфейс</h3>
    <p>
        Это всего-лишь интерфейс маркер по типу serializable, который говорит лишь о том, что мы можем использовать
        объекты типа <code>Extension</code> как модель для расширения наших классов.
    </p>
    <p>
        Поэтому создали <code>UserServiceParamResolver</code>, который имплементил <code>ParameterResolver</code>,
        который в свою очередь является нашим <code>Extension</code>'ом. Нам надо было реализовать всего лишь
        два простых метода и которые автоматически вызывались у нас во время выполнения наших тестов.
    </p>
    <p>
        У нас появляется очень интересный момент - это <code>ExtensionContext</code>. Это по сути полная информация
        по нашему <code>ExtensionContext</code> выполнению. И здесь мы можем получить довольно много информации.
    </p>
    <h2>Возвращаясь к parameter resolution который реализовали</h2>
    <p>
        Мы так же использовали наш <code>ExtensionContext</code> к примеру, для того чтобы получить тестовый метод
        название которого мы определили: какое хранилище использовать (<code>getStore</code>). <code>Store</code> - это
        что-то вроде хранилища для наших тестов которые мы можем в последующем использовать как ассоциативный массив
        где по ключу можем получить значение.
    </p>
    <p>
        Если перейдём в <code>Extension</code> и посмотрим какие есть по умолчанию, то приходим к пяти основным
        Extension Model'ям:
    </p>
    <img src="ju-14-2.png" alt="ju-14-2" width="40%">
    <p>
        Первое - это callback'и нашего жизненного цикла. <code>AfterAllCallback</code>, <code>AfterEachCalbback</code>
        и так на каждую из наших фаз. Далее основные интерфейсы - это <code>ExecutionCondition</code>, т.е. на
        выполнение
        наших условий. <code>ParameterResolver</code> уже прошли, это для наших параметров. Далее, для исключений это
        <code>TestExecutionExceptionHandler</code>. Для того чтобы подключить инстанс тестовый -
        <code>testInstancePostProcessor</code>.
    </p>
    <p>
        Таким образом, у нас уже есть готовые интерфейсы для каждого из пяти вариантов Extension Model'и и мы просто
        можем создать свою реализацию этих интерфейсов и подключить её с помощью аннотации <code>@ExtendWith({})</code>.
    </p>
    <p>
        <b>В основном</b> фреймворки или какие-то библиотеки чаще прибегают к Extension Model'и, к написанию своих
        собственных callback'ов. В обычной ситуации, обычные программисты просто используют существующие подключая
        те или иные библиотеки или фреймворки такие, как Mockito и Spring.
    </p>
</article>
<article>
    <h1>JUnit 5. 13. Flaky tests. Timeouts</h1>
    <p>
        <b>Flaky tests</b> означает, что тест не стабильный. Т.е когда запускаем наши тесты во время разработки, то
        бывает падают тесты в рандомном месте при чем после перезапуска они могут их даже проходить при чем несколько
        раз.
        Но например на четвертый запуск вновь упали. Это может быть связано как с неправильной реализацией этих тестов.
        Опять же возвращаемся к порядку следований этих тестов. Это все тот же относится к тому, что мы не должны
        завязываться на порядок выполнения тестов в нашем коде. Более того, это часто относится к integration и
        даже acceptance тестам, которые задействуют например состояние нашей базы данных и могут изменять данные в ней.
        И не почистив за собой что повлечёт за собой негативные изменения в других тестах, которые планировали
        получить другой датасет в базе данных.
    </p>
    <p>
        Поэтому так как по умолчанию поля тестов не детерминированы, следовательно, могут падать различные тесты в
        рандомном месте. <i>Что обычно делают программисты:</i> находят этот тест (например
        <code>loginFailIfPasswordIsNotCorrect</code>) и помечают аннотацией <code>@Disabled</code>. Т.е. эта аннотация
        позволяет не запускать наш тест в следующий раз. Обычно пишут комментарий, у этой аннотации есть всего лишь
        одно поле - это <code>value</code> и, например пишут:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        @Disabled("flaky, need to see")
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }
    </pre>
    <img src="ju-13-1.png" alt="ju-13-1" width="30%">
    <p>
        <b>Второй вариант</b>, как уменьшить кол-во flaky test'ов - это сделать их <b>repeatable</b>. Т.е. есть ещё одна
        аннотация <code>@RepeatedTest()</code> в котором указывает сколько повторений должно быть и его название (есть
        по умолчанию):
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    //        @Test
            @RepeatedTest(value = 5, name = RepeatedTest.LONG_DISPLAY_NAME)
            void loginFailIfUserDoesNotExist() {
                userService.add(VADIM);
    
                Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());
    
                assertTrue(maybeUser.isEmpty());
            }
    </pre>
    <img src="ju-13-2.png" alt="ju-13-2" width="30%">
    <p>
        Таким образом мы можем улучшить наши тесты, которые поддержаны к тому, чтобы поддерживать наши flacky. Т.е.
        например на 3 и 4 итерации часто падает тест, хотя предыдущие два проходят. Таким образом уменьшаем кол-во
        таких flacky-тестов. Более того, можем использовать DI механизм и передать <code>RepetitionInfo</code>.
        По сути, это информация про кол-во итераций, про текущую итерации:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    //        @Test
            @RepeatedTest(value = 5, name = RepeatedTest.LONG_DISPLAY_NAME)
            void loginFailIfUserDoesNotExist(RepetitionInfo repetitionInfo) {
                userService.add(VADIM);
    
                Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());
    
                assertTrue(maybeUser.isEmpty());
            }
    </pre>
    <h2>Timeout'ы</h2>
    <p>
        На одном из предыдущих занятий мы видили, что в старом JUnit 4 (
        <code>@org.junit.Test(expected = IllegalArgumentException.class)</code>) кроме значения <code>expected</code>
        был ещё один - это <code>long timeout</code>. Т.е. могли таймауты на ограничения во время выполнения нашего
        теста. Естественно для юнит тестов он <b>не годится</b>, но для интеграционных, а скорее для acceptance-тестов
        вполне себе <b>годится</b> потому что они могут занимать довольно много времени.
    </p>
    <p>
        Например, наш логин можем протестировать следующим образом:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
            @Test
            void checkLoginFunctionalityPerfomance() {
    //            Тестируем время выполнения нашего теста
                Optional&lt;User> result = assertTimeout(
                        Duration.ofMillis(200L),
                        () -> {
                            Thread.sleep(300L);
                            return userService.login("Dima", VADIM.getPassword());
                        }
                );

            }
    </pre>
    <img src="ju-13-3.png" alt="ju-13-3" width="30%">
    <p>
        Видим, что тест провален потому что ожидали время выполнения не более 200мс, а выполнилось более чем за 300мс.
    </p>
    <p>
        Так же есть другой ассерт, это <code>assertTimeoutPreemptively()</code>, который отличается лишь тем, что
        выполняется наш метод в отдельном потоке. В этом случае получаем разные потоки:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
            @Test
            void checkLoginFunctionalityPerfomance() {
                System.out.println(Thread.currentThread().getName());
    //            Тестируем время выполнения нашего теста
                Optional&lt;User> result = assertTimeoutPreemptively(
                        Duration.ofMillis(200L),
                        () -> {
                            System.out.println(Thread.currentThread().getName());
                            Thread.sleep(300L);
                            return userService.login("Dima", VADIM.getPassword());
                        }
                );
    
            }
    </pre>
    <img src="ju-13-4.png" alt="ju-13-4" width="60%">
    <p>
        Сначала видим поток <i>main</i>, а затем поток <i>junit-timeout-thread-1</i>. Т.е. запущен в другом потоке.
    </p>
    <p>
        Чаще всего используется <code>assertTimeout()</code> потому что множество функциональностей, например в спринге
        связанной с транзакциями завязано на такие переменные как <code>ThreadLocal</code>, который использует объект
        текущего потока в качестве ключа для определения транзакций. Поэтому чаще прибегают к обычным
        <code>assertTimeout()</code>.
    </p>
    <p>
        Есть так же отдельная аннотация <code>@Timeout()</code>, в котором в качестве параметра принимаем значение и
        время
        в мс (<code>long value</code>). В нашем случае ожидаем 200мс, то делаем следующее:
    </p>
    <p>
        Мы так же можем указывать его как над методами, так и над классами. Поставим его над внутренним классом
        <code>@Timeout(value = 200, unit = TimeUnit.MILLISECONDS)</code>:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Nested
    @DisplayName("test user login functionality")
    @Tag("login")
    @Timeout(value = 200, unit = TimeUnit.MILLISECONDS)
    class LoginTest {
    </pre>
</article>
<article>
    <h1>JUnit 5. 12. Parameterized Tests</h1>
    <p>
        DI механизм принёс очень много полезных изменений. Т.е. на основании DI у нас появилась возможность использовать
        такие вещи как <b>параметризованные тесты</b>.
    </p>
    <h2>Посмотрим что такое параметризованные тесты</h2>
    <p>
        Но для этого нам необходимо подключить дополнительную зависимость:
    </p>
    <pre>
        &lt;dependency>
            &lt;groupId>org.junit.jupiter&lt;/groupId>
            &lt;artifactId>junit-jupiter-params&lt;/artifactId>
            &lt;version>5.8.0-M1&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
    <p>
        У нас появляется новая возможность писать тесты именно параметризованные тесты. Вместо того чтобы писать
        аннотацию <code>@Test</code> мы используем <code>@ParameterizedTest</code>. Далее пишем как обычный тест и
        например хотим протестировать нашу логин-функциональность большинством тест-кейсов. Т.е. когда у нас есть
        существующий юзер и несуществующий, и проблема с юзернеймом, паролем и т.д.. Т.е. этим кейсом можем закрыть
        сразу множество тест-кейсов. Для этого как раз таки подходят параметризованные тесты.
    </p>
    <p>
        И теперь, суть его в том, что мы пишем, как обычно, но в методы передаём аргументы из параметризованного теста.
        Т.е. берутся из DI-механизма. Мы просто просим предоставить нам поля <code>String username, String
        password</code>.
    </p>
    <p>
        Теперь, чтобы подставить username & password мы тоже должны предоставить какой-то класс, либо функциональность,
        которая предоставит нам эти значения с помощью DI. И для этого вместе с <code>@ParameterizedTest</code> всегда
        используется ещё одна аннотация: <code>@ArgumentsSource()</code>. Эту аннотацию можно ставить как над
        аннотацией, так и методом. Внутри себя он содержит <code>value()</code>, который представляет класс-провайдер.
        Его единственная задача: предоставить поток аргументов в наш метод. Он занимается тем, что находит наши
        аргументы (в нашем случае username и password) и это все представляется в виде аргументов. А аргумент - это
        всего лишь интерфейс, который возвращает массив объектов. Т.е. если у нас к примеру два параметра в нашем
        методе, то это массив из двух элементов.
    </p>
    <p>
        Есть уже множество готовых провайдеров. Мы можем ими воспользоваться чтобы не писать свои провайдеры:
    </p>
    <pre>
            @ParameterizedTest
    //        Для кастомных провайдеров
    //        @ArgumentsSource()
    //        Реализовывает NullArgumentsProvider
            @NullSource
    //        Реализовывает EmptyArgumentsProvider
            @EmptySource
    //        Реализовывает ValueArgumentsProvider
            @ValueSource
            void loginParameterizedTest(String username, String password) {
                userService.add(VADIM, PETR);
                Optional&lt;User> maybeUser = userService.login(username, password);
            }
    </pre>
    <p>
        Не сложно догадаться, что наши провайдеры подставляют значения в параметры. Единственное ограничение, что
        параметр должен быть один. В нашем случае username и password - это два параметра и следовательно, что для
        <code>@NullSource</code>, что и для <code>@EmptySource</code>, <code>@ValueSource</code> есть ограничения в
        один единственный параметр. Поэтому и используют их довольно редко. Но если у нас одна красивая функция с
        одним параметром, то это отличный вариант использовать <code>@NullSource</code>,<code>@EmptySource</code>,
        <code>@ValueSource</code>.
    </p>
    <p>
        Уберём один аргумент и запустим код в дебаге:
    </p>
    <pre>
            @ParameterizedTest
    //        Для кастомных провайдеров
    //        @ArgumentsSource()
    //        Реализовывает NullArgumentsProvider
            @NullSource
    //        Реализовывает EmptyArgumentsProvider
            @EmptySource
    //        @NullAndEmptySource
    //        Реализовывает ValueArgumentsProvider
    //        @ValueSource
            void loginParameterizedTest(String username) {
                userService.add(VADIM, PETR);
                Optional&lt;User> maybeUser = userService.login(username, null);
            }
    </pre>
    <img src="ju-12-1.png" alt="ju-12-1" width="60%">
    <p>
        Видим пустое значение в username потому что со String он работает так же как с массивами и коллекциями.
        <code>@ValueSource</code> работает так же только с одним параметром. Например, в данном случае если у нас только
        один параметр, то я могу предоставить <code>strings</code>:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
            @ParameterizedTest
    //        Для кастомных провайдеров
    //        @ArgumentsSource()
    //        Реализовывает NullArgumentsProvider
            @NullSource
    //        Реализовывает EmptyArgumentsProvider
            @EmptySource
    //        @NullAndEmptySource
    //        Реализовывает ValueArgumentsProvider
            @ValueSource(strings = {
                    "Vadim", "Petr"
            })
            void loginParameterizedTest(String username) {
                userService.add(VADIM, PETR);
                Optional&lt;User> maybeUser = userService.login(username, null);
            }
    </pre>
    <p>
        И если запустим дебаг, то в username сначала придёт Vadim, а потом Petr. Есть ещё один тип source'ов - это
        <code>@EnumSource</code>: используется редко - только тогда, когда у нас есть Enum вместо каких-то примитивных
        типов либо String.
    </p>
    <p>
        Что нельзя сказать про <code>@MethodSource</code> - он используется чаще всего. Мы должны предоставить ему
        название нашего метода, который примет все эти стримы аргументов. Т.е. я должен передать метод и создать его.
        Он должен быть статическим и возвращать <code>Stream&lt;Arguments></code>. Есть конечно ограничения, что
        статические методы нельзя использовать во внутренних классах, следовательно, мы должны его вынести в наш
        внешний класс. Теперь у нас нет доступа к <code>getArgumentsForLoginTest</code> методу потому что он уже
        находится не во внутреннем классе, а в каком-то другом. Но опять же, у нас есть возможность указывать любой
        статический метод в <code>@MethodSource</code>, не только внутри класса, где пишем метод. Для этого пишем
        путь к методу. Пусть состоит из полного пути класса, где состоит метод.
    </p>
    <b>UserServiceTest.java</b>
    <pre>
            @ParameterizedTest
    //        Для кастомных провайдеров
    //        @ArgumentsSource()
    //        Реализовывает NullArgumentsProvider
    //        @NullSource
    //        Реализовывает EmptyArgumentsProvider
    //        @EmptySource
    //        @NullAndEmptySource
    //        Реализовывает ValueArgumentsProvider
    //        @ValueSource(strings = {
    //                "Vadim", "Petr"
    //        })
    //        @EnumSource
            @MethodSource("com.kainv.junit.service.UserServiceTest#getArgumentsForLoginTest")
            void loginParameterizedTest(String username, String password, Optional&lt;User> user) {
                userService.add(VADIM, PETR);

                Optional&lt;User> maybeUser = userService.login(username, password);

                assertThat(maybeUser).isEqualTo(user);
            }
        }

        static Stream&lt;Arguments> getArgumentsForLoginTest() {
            return Stream.of(
                    Arguments.of("Vadim", "123", Optional.of(VADIM)),
                    Arguments.of("Petr", "123", Optional.of(PETR)),
    //                    Существующий пользователь, но неправильный пароль
                    Arguments.of("Petr", "dummy", Optional.empty()),
    //                    Пользователя не существует, а пароль существует
                    Arguments.of("dummy", "123", Optional.empty())
            );
        }
    </pre>
    <p>
        Таким образом мы можем сразу четыре кейса покрыть тестами. Запускаем наш тест и проверяем:
    </p>
    <img src="ju-12-2.png" alt="ju-12-2" width="30%">
    <p>
        Мы можем использовать обычный CSV формат и указать просто путь к нему. Для этого в тестовой директории создаём
        resources и там создаём файл <b>login-test-data.csv</b>. Т.е. именно расширение csv. Суть этого формата в том,
        что мы на каждой строке пишем какие-то значения, которые разделены любым делиметром.
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @ParameterizedTest
        @CsvFileSource(resources = "/login-test-data.csv", delimiter = ',', numLinesToSkip = 1)
        void loginParameterizedTest(String username, String password) {
            userService.add(VADIM, PETR);

            Optional&lt;User> maybeUser = userService.login(username, password);

            assertThat(maybeUser).isEqualTo(null);
        }
    </pre>
    <p>
        Если запустим этот код в дебаге, то в наши параметры передадутся все необходимые данные. Так же чтобы не
        создавать csv файл мы можем использовать аннотацию <code>@CsvSource</code>:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @ParameterizedTest
        @CsvSource({
                "Vadim,123",
                "Petr,123"
        })
        void loginParameterizedTest(String username, String password) {
            userService.add(VADIM, PETR);

            Optional&lt;User> maybeUser = userService.login(username, password);

            assertThat(maybeUser).isEqualTo(null);
        }
    </pre>
    <p>
        Так же можем именовать тесты при помощи <code>@ParameterizedTest(name = "")</code>. Внутри него есть
        разные <i>placeholder</i>'ы:
    </p>
    <pre>
        @ParameterizedTest(name = "{arguments} test")
        @MethodSource("com.kainv.junit.service.UserServiceTest#getArgumentsForLoginTest")
        void loginParameterizedTest(String username, String password, Optional&lt;User> user) {
            userService.add(VADIM, PETR);

            Optional&lt;User> maybeUser = userService.login(username, password);

            assertThat(maybeUser).isEqualTo(user);
        }
    </pre>
    <p>
        Запустим все тесты и посмотрим на результат:
    </p>
    <img src="ju-12-3.png" alt="ju-12-3" width="30%">
    <p>
        Если хотим переименовать название теста, то используем обычный <code>@DisplayName("")</code>:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @ParameterizedTest(name = "{arguments} test")
        @MethodSource("com.kainv.junit.service.UserServiceTest#getArgumentsForLoginTest")
        @DisplayName("login param test")
        void loginParameterizedTest(String username, String password, Optional&lt;User> user) {
            userService.add(VADIM, PETR);

            Optional&lt;User> maybeUser = userService.login(username, password);

            assertThat(maybeUser).isEqualTo(user);
        }
    </pre>
    <img src="ju-12-4.png" alt="ju-12-4" width="30%">
</article>
<article>
    <h1>JUnit 5. 11. Dependency Injection. DI</h1>
    <p>
        Начиная c JUnit 5 нам добавили возможность использовать такой паттерн <i>Dependency Injection</i> который
        говорит нам о том, что есть какой-то объект либо совокупность этих объектов, который предоставляет нам
        зависимости для других объектов.
    </p>
    <p>
        Например есть <code>UserServiceTest</code>, который зависит от <code>UserService</code>. Следовательно,
        <code>UserService</code> это зависимость у нашего <code>UserServiceTest</code>. Поэтому DI говорит нам о том,
        что у нас есть какой-то сторонний объект, который предоставит нам этот <code>UserService</code> если
        попросим его для нашей <code>UserServiceTest</code>.
    </p>
    <p>
        Такой подход есть во многих фреймворках. В реальной практике когда используем JUnit фреймворк вместе со
        спрингом, то используется именно DI спринга. Но если нет спринга и используем JUnit 5, то можем воспользоваться
        DI механизмом для реализации своих нужд.
    </p>
    <p>
        Например, можем создать конструктор <code>UserServiceTest</code> и в нём попросить какую-ту зависимость.
        Например <code>TestInfo</code>, т.е. я хочу чтобы какой-то объект который занимается предоставлением
        зависимостей мне дал объект с типом <code>TestInfo</code>. Более того, мы используем конструктор в своём
        <code>UserServiceTest</code>, в предыдущих версиях JUnit нельзя было делать такие конструкторы с какими-то
        параметрами потому что было обязательное требование - это то, что у тестового класса должен быть конструктор
        без параметров.
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    UserServiceTest(TestInfo testInfo) {
        System.out.println();
    }
    </pre>
    <p>
        Теперь, если запустим <code>UserServiceTest</code> в дебаге внутри конструктора, то увидим, что у нас в
        <code>testInfo</code> приходит какой-то объект, который содержит информацию:
    </p>
    <img src="ju-11-1.png" alt="ju-11-1" width="60%">
    <p>
        <code>testMethod</code> говорит о том, что мы можем использовать такой механизм DI не только в конструкторах,
        но и в тестовых методах. По сути, когда вспоминаем тему про жизненный цикл тестов, то можем использовать DI
        для всех наших основных аннотаций (<code>@BeforeAll</code> - <code>@AfterAll</code>).
    </p>
    <p>
        <b>Как работает такой механизм?</b> Есть специальный класс, который называется <code>ParameterResolver</code>
        который наследуется от <code>Extension</code>. В <code>ParameterResolver</code> есть два метода:
    </p>
    <img src="ju-11-2.png" alt="ju-11-2" width="60%">
    <p>
        <code>supportsParameter</code> вызывается вначале когда DI фреймворк определяет, подходит ли этот
        параметр нашего метода под наш параметр resolver который предоставит в последующем объект этого
        типа. Если подходит, то вызывается <code>resolveParameter</code> и мы должны вернуть этот объект.
        Если нет, то resolver параметр не возвращается.
    </p>
    <p>
        Уже есть готовые параметры resolver'ы. Как раз тот <code>TestInfo</code> который видели это
        <code>TestInfoParameterResolver</code>. Самое интересное это то, что мы можем реализовывать свои
        ParameterResolver'ы.
    </p>
    <p>
        Например, в <code>UserServiceTest</code> хотим добавить параметр-resolver который предоставит
        <code>UserService</code>. Для этого создадим пакет <b>paramresolver</b> и создадим класс
        <code>UserServiceParamResolver</code> и всё что необходимо сделать - это реализовать интерфейс
        <code>ParamResolver</code>:
    </p>
    <pre>
    package com.kainv.junit.paramresolver;

    import org.junit.jupiter.api.extension.ExtensionContext;
    import org.junit.jupiter.api.extension.ParameterContext;
    import org.junit.jupiter.api.extension.ParameterResolutionException;
    import org.junit.jupiter.api.extension.ParameterResolver;

    public class UserServiceParamResolver implements ParameterResolver {
        @Override
        public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
            return false;
        }

        @Override
        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
            return null;
        }
    }
    </pre>
    <p>
        Теперь должны эти два метода реализовать. <code>ParameterContext</code> это объект говорящий нам всю информацию
        о параметре, который мы в последующем либо за-inject'им (будем зависимы) вернув true либо нет вернув false.
        У него есть куча методов, но главный из них это <code>getParameter()</code>.
    </p>
    <pre>
    package com.kainv.junit.paramresolver;

    import com.kainv.service.UserService;
    import org.junit.jupiter.api.extension.ExtensionContext;
    import org.junit.jupiter.api.extension.ParameterContext;
    import org.junit.jupiter.api.extension.ParameterResolutionException;
    import org.junit.jupiter.api.extension.ParameterResolver;

    public class UserServiceParamResolver implements ParameterResolver {
        @Override
        public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
    //        Определим тип параметра и если он равен UserService.class, то это отличный вариант чтобы мы установили в качестве зависимости свой
            return parameterContext.getParameter().getType() == UserService.class;
        }

        @Override
        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
            return new UserService();
        }
    }
    </pre>
    <p>
        Здесь мы просто создаём через <code>new</code>, но в реальных проектах мы можем иметь более сложный механизм
        соединения этих зависимостей.
    </p>
    <p>
        Теперь в <code>UserServiceTest</code> и попросим <code>UserService</code> для нашего <code>prepare()</code>
        метода:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @BeforeEach
    void prepare(UserService userService) {
        System.out.println("Before each: " + this);
        this.userService = userService;
    }
    </pre>
    <p>
        И теперь вместо того, чтобы создавать его самим - мы просим его у нашего фреймворка. Для того чтобы использовать
        этот <code>UserServiceParamResolver</code> мы должны помочь DI механизму. Для этого используется наша
        Extension модель <code>@ExtendWith()</code> в которую передаём все классы-extension. Т.е. мы уходим от всех
        правил JUnit 4 и просто добавляем какой-то функционал к нашему тесту. Т.е. реализуем его.
    </p>
    <pre>
    @Tag("fast")
    @Tag("user")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @TestMethodOrder(MethodOrderer.DisplayName.class)
    @ExtendWith({
            UserServiceParamResolver.class
    })
    public class UserServiceTest {
    </pre>
    <p>
        Это уже как бы минус для DI механизма, что должны указывать такие ресловеры. Спринг в таком плане поможет
        решить эту проблему. Установим брекпоинты в этих местах:
    </p>
    <img src="ju-11-3.png" alt="ju-11-3" width="60%">
    <p>
        И запустим дебаг:
    </p>
    <img src="ju-11-4.png" alt="ju-11-4" width="60%">
    <p>
        Мы пришли в <code>UserServiceParamResolver</code>. Во-первых он создаётся один раз, т.е. даже если мы несколько
        раз пытаемся предоставить <code>UserService</code> объект в наших методах, то
        <code>UserServiceParamResolver</code>
        у нас один как синглтон. Это очень важно потому что мы можем к примеру реализовать какой-то функционал для
        кэширования объектов. Т.е. если не хотим каждый раз возвращать новый объект <code>UserService</code>, то можем
        создать поле в <code>UserServiceParamResolver</code> и только один раз его проинициализировать.
    </p>
    <p>
        Мы получили параметр <code>parameterContent</code> в котором видим, что сейчас требуется TestInfo. Т.к. это
        ParameterResolver для UserService, то он вернёт false и <code>resolveParameter</code> не отработает.
    </p>
    <p>
        Продолжим выполнение программы и получим:
    </p>
    <img src="ju-11-5.png" alt="ju-11-5" width="60%">
    <p>
        Теперь просим получить <code>UserService</code>. <code>parameterContext</code> вернёт true и вызовется
        <code>resolveParameter</code>:
    </p>
    <img src="ju-11-6.png" alt="ju-11-6" width="60%">
    <p>
        Мы видим все тот же <code>parameterContext</code> и <code>extensionContext</code>. В
        <code>extensionContext</code>
        хранится информация о нашем классе.
    </p>
    <h2>Что ещё есть в этом ParameterResolver'е</h2>
    <p>
        Мы можем закешировать <code>UserService</code>, но есть готовый инструмент для кеширования:
        <code>extensionContext.getStore(Namespace namespace)</code>. Namespace - это по сути ключ для нашего
        getStore. Неймспейсы можно создавать свои или использовать один глобальный:
    </p>
    <b>UserServiceParamResolver.java</b>
    <pre>
        @Override
        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
    //        Для методов которые требуют UserService мы возвращаем всегда один и тот же store:
            ExtensionContext.Store store = extensionContext.getStore(ExtensionContext.Namespace.create(UserService.class));
    //        Получаем по ключу значение
            return store.getOrComputeIfAbsent(UserService.class, it -> new UserService());
        }
    </pre>
    <p>
        <code>.create()</code> принимает массив, поэтому можем создать какой угодно сложный ключ, чтобы возвращать один
        объект или разные. В данном случае будет возвращаться один и тот же объект потому что мы получаем Namespace
        один и тот же (<code>UserService</code>) но мы к примеру можем опираться не на <code>UserService.class</code>,
        а на название метода. Тогда для каждого метода создавался бы заново наш <code>UserService</code>:
    </p>
    <b>UserServiceParamResolver.java</b>
    <pre>
        @Override
        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
    //        Для методов которые требуют UserService мы возвращаем всегда один и тот же store:
            ExtensionContext.Store store = extensionContext.getStore(Namespace.create(extensionContext.getTestMethod()));
    //        Получаем по ключу значение
            return store.getOrComputeIfAbsent(UserService.class, it -> new UserService());
        }
    </pre>
    <p>
        Лучше метод использовать в качестве ключа в том же объекте store, чтобы не создавать новый store.
    </p>
    <p>
        Таких <code>ParameterResolver</code>'ов можем создавать сколько угодно потому что <code>@ExtendWith</code>
        принимает массив таких екстеншинов. На практике они не так часто используются потому что в основном предпочитают
        использовать DI от Spring.
    </p>
</article>
<article>
    <h1>JUnit 5. 10. Tests order. Nested tests</h1>
    <p>
        Не стоит отталкиваться от того, что наши методы будут вызываться в определенном порядке потому что этот порядок
        в JUnit 5 не определён. Т.е. есть какой-то алгоритм, который запускает наши методы тестовые в каких то классах
        тестовых. Но он чисто используется для того чтобы при запуске нашего тестового класса эти методы всегда
        запускались в одном и том же порядке. Но сам порядок не гарантирован. Даже есть такой
        <i>chain gang anti-pattern</i> который как раз таки и описывает нашу ситуацию когда завязываемся на порядок
        выполнения наших тестов. Тем не менее в JUnit 5 есть возможность указать порядок. На практике лучше стараться
        не использовать это средство. За это отвечает аннотация <code>@TestMethodOrder()</code>, куда передаём
        класс, который наследуется от <code>MethodOrdered</code>. Это интерфейс, в котором есть пять реализаций:
    </p>
    <ol>
        <li>
            <b>MethodName</b> - по названию наших методов в алфавитном порядке будут вызываться все наши тесты
            устанавливаем аннотацию <code>@TestMethodOrder(MethodOrderer.MethodName.class)</code>. Запускаем и видим:
            <br>
            <img src="ju-10-2.png" alt="ju-10-2" width="30%">
        </li>
        <li>
            <b>DisplayName</b> - на самом деле это то название, которое получаем при отображении этих тестов. Не
            названия методов, а отображение названий этих методов. Для того чтобы создать DisplayName
            используем специальную аннотацию <code>@DisplayName()</code> куда передаём уже строку. Например:
            <br>
            <b>UserServiceTest.java</b>
            <pre>
    @Test
    @Order(1)
    @DisplayName("users will be empty if no user added")
    void usersEmptyIfNoUserAdded() {
        System.out.println("Test 1: " + this);

        List&lt;User> users = userService.getAll();

        MatcherAssert.assertThat(users, IsEmptyCollection.empty());
        assertTrue(users.isEmpty(), () -> "User list should be empty");
    }
            </pre>
            <p>
                И при запуске операция будет именно на <code>@DisplayName()</code>:
            </p>
            <img src="ju-10-3.png" alt="ju-10-3" width="30%">
        </li>
        <li>
            <b>OrderAnnotation</b> - используется если хотим помечать все тесты аннотацией <code>@Order</code>. Т.е.
            дополнительно каждый тест помечается аннотацией <code>@Order</code> и в ней есть один параметр обязательный:
            <code>value</code>. Т.е. нумерация от 1 до бесконечности.
            <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.hamcrest.MatcherAssert;
    import org.hamcrest.collection.IsEmptyCollection;
    import org.hamcrest.collection.IsMapContaining;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Map;
    import java.util.Optional;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.junit.jupiter.api.Assertions.*;

    @Tag("fast")
    @Tag("user")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @TestMethodOrder(MethodOrderer.OrderAnnotation.class)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        @Order(1)
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);

            List&lt;User> users = userService.getAll();

            MatcherAssert.assertThat(users, IsEmptyCollection.empty());
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        @Order(2)
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertThat(users).hasSize(2);
    //        assertEquals(2, users.size());
        }

        @Test
        @Tag("login")
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        @Tag("login")
        void throwExceptionIfUsernameOrPasswordIsNull() {
            assertAll(
                    () -> {
                        IllegalArgumentException argumentException = assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
                        assertThat(argumentException.getMessage()).isEqualTo("username or password is null");
                    },
                    () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
            );
        }

        @Test
        @Tag("login")
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void usersConvertedToMapById() {
            userService.add(VADIM, PETR);

            Map&lt;Integer, User> users = userService.getAllConvertedById();

            MatcherAssert.assertThat(users, IsMapContaining.hasKey(VADIM.getId()));

            assertAll(
                    () ->
                            // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                            assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                    () ->
                            // Проверяем Map не только на содержание, но и значений
                            assertThat(users).containsValues(VADIM, PETR)
            );
        }

        @Test
        @Tag("login")
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
            <img src="ju-10-1.png" alt="ju-10-1" width="30%">
            <p>
                Видим, что тесты в которых пометили порядок - запустились первыми по порядку. Остальные запустились в
                неопределённом порядке.
            </p>
        </li>
        <li>
            <b>Random</b> - каждый раз когда вызываем тесты в <code>UserServiceTest</code> все наши тесты будут
            выполнятся в рандомном порядке.
        </li>
    </ol>
    <p>
        Лучше <b>не использовать</b> <code>@TestMethodOrder</code> вовсе чтобы не реализовывать наш <i>chain gang
        anti-pattern</i> и избегать всяких <i>flaky tests</i> (позже будут объяснения). <code>@DisplayName</code>
        можно использовать, чтобы улучшить название наших тестовых методов когда их запускаем. Более того, для того
        чтобы пойти ещё дальше, улучшить читабельность тестов и как то их разделить.
    </p>
    <p>
        Например у нас много методов связанных с логином поэтому можем использовать т.н. nested-classes. Т.е. можем
        создать внутренний класс и туда перенести все тестовые методы, которые связаны с логином:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.hamcrest.MatcherAssert;
    import org.hamcrest.collection.IsEmptyCollection;
    import org.hamcrest.collection.IsMapContaining;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Map;
    import java.util.Optional;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.junit.jupiter.api.Assertions.*;

    @Tag("fast")
    @Tag("user")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @TestMethodOrder(MethodOrderer.DisplayName.class)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        @Order(1)
        @DisplayName("users will be empty if no user added")
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);

            List&lt;User> users = userService.getAll();

            MatcherAssert.assertThat(users, IsEmptyCollection.empty());
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        @Order(2)
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertThat(users).hasSize(2);
    //        assertEquals(2, users.size());
        }

        @Test
        void usersConvertedToMapById() {
            userService.add(VADIM, PETR);

            Map&lt;Integer, User> users = userService.getAllConvertedById();

            MatcherAssert.assertThat(users, IsMapContaining.hasKey(VADIM.getId()));

            assertAll(
                    () ->
                            // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                            assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                    () ->
                            // Проверяем Map не только на содержание, но и значений
                            assertThat(users).containsValues(VADIM, PETR)
            );
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }

        @Nested
        @Tag("login")
        class LoginTest {
            @Test
            void loginSuccessIfUserExists() {
                userService.add(VADIM);
                userService.add(PETR);

                Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

                // Проверяем, что такой пользователь существует
                assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
                // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
                maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
            }

            @Test
            void throwExceptionIfUsernameOrPasswordIsNull() {
                assertAll(
                        () -> {
                            IllegalArgumentException argumentException = assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
                            assertThat(argumentException.getMessage()).isEqualTo("username or password is null");
                        },
                        () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
                );
            }

            @Test
            void loginFailIfPasswordIsNotCorrect() {
                userService.add(VADIM);

                Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

                assertTrue(maybeUser.isEmpty());
            }

            @Test
            void loginFailIfUserDoesNotExist() {
                userService.add(VADIM);

                Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

                assertTrue(maybeUser.isEmpty());
            }
        }
    }
    </pre>
    <p>
        Теперь нет нужды помечать аннотацией <code>@Tag("")</code> потому что можно поставить аннотацию над классом
        (все методы внутри будут автоматически с этим тэгом). Чтобы внутренний класс был как обычные тесты, мы должны
        его пометить аннотацией <code>@Nested</code>.
    </p>
    <p>
        Запускаем и проверяем:
    </p>
    <img src="ju-10-4.png" alt="ju-10-4" width="30%">
    <p>
        Более того, наш <code>@DisplayName("")</code> можно использовать над <code>@Nested</code> классами и не только.
        Следовательно, можем улучшить читабельность кода:
    </p>
    <pre>
    @Nested
    @DisplayName("test user login functionality")
    @Tag("login")
    class LoginTest {
    </pre>
    <img src="ju-10-5.png" alt="ju-10-5" width="30%">
</article>
<article>
    <h1>JUnit 5. 9. Tagging and Filtering</h1>
    <p>
        Тэги - это новая функциональность в JUnit 5, благодаря которой можем отфильтровывать наши тесты. Эта аннотация
        так и называется: <code>@Tag</code> (<code>@Tags</code> позволяет совмещать несколько тегов над одним методом
        или классом). Аннотация <code>@Tag</code> принимает одно значение - <code>values</code>.
    </p>
    <p>
        Поставим тег над тестами, которые относятся к логину:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.hamcrest.MatcherAssert;
    import org.hamcrest.collection.IsEmptyCollection;
    import org.hamcrest.collection.IsMapContaining;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Map;
    import java.util.Optional;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);

            List&lt;User> users = userService.getAll();

            MatcherAssert.assertThat(users, IsEmptyCollection.empty());
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertThat(users).hasSize(2);
    //        assertEquals(2, users.size());
        }

        @Test
        @Tag("login")
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        @Tag("login")
        void throwExceptionIfUsernameOrPasswordIsNull() {
            assertAll(
                    () -> {
                        IllegalArgumentException argumentException = assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
                        assertThat(argumentException.getMessage()).isEqualTo("username or password is null");
                    },
                    () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
            );
        }

        @Test
        @Tag("login")
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void usersConvertedToMapById() {
            userService.add(VADIM, PETR);

            Map&lt;Integer, User> users = userService.getAllConvertedById();

            MatcherAssert.assertThat(users, IsMapContaining.hasKey(VADIM.getId()));

            assertAll(
                    () ->
                            // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                            assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                    () ->
                            // Проверяем Map не только на содержание, но и значений
                            assertThat(users).containsValues(VADIM, PETR)
            );
        }

        @Test
        @Tag("login")
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
    <p>
        Такая возможность позволяет запускать только те тесты, которые помечены тэгом login. Либо например очень часто
        встречается такая возможность как запускать только те тесты, которые к примеру только unit:
    </p>
    <pre>
    @Tag("fast")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {
    </pre>
    <p>
        А интеграционные и Acceptance тесты будут помечены другими тегами. Особенно эти теги играют решающую роль для
        сложных тестов (Acceptance тестов), которые занимают довольно большую часть времени. И, следовательно, очень
        удобно запускать только те тесты, которые относятся к определенной предметной области, которую тестируем или на
        которой пишем тесты.
    </p>
    <p>
        Например, у нас есть большая функциональность на нашего пользователя. Следственно, все тесты которые помечены
        тэгом <code>@Tag("user")</code> нам нужно запускать и проверять. Это нам спасает очень большое кол-во времени
        для тестировщика:
    </p>
    <pre>
    @Tag("fast")
    @Tag("user")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {
    </pre>
    <h2>Разберёмся как запускать тесты по тегам</h2>
    <p>
        Если перейдём в класс <code>TestLauncher</code> где проверяли как вручную запускать тесты. Т.е. то что делают
        наши среды разработки и build-tools вроде maven'а и gradle'а под капотом. В данном случае видим, что у нас
        есть ещё один метод <code>.filters</code> и мы можем в него передавать различные фильтры. Чаще всего
        используются такие фильтры как <i>include</i> и <i>exclude</i> по префиксу или суффиксу. Так же можно
        использовать <code>TagFilter</code> в котором можно включать и исключать определенные тэги.
    </p>
    <p>
        Например, я хочу запускать только те теги, которые помечены login:
    </p>
    <pre>
    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();
    //        launcher.registerTestExecutionListeners();

            SummaryGeneratingListener summaryGeneratingListener = new SummaryGeneratingListener();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .filters(
                            TagFilter.includeTags("login")
                    )
                    .build();

            launcher.execute(request, summaryGeneratingListener);

    //        Выводим результат тестирования
            try (PrintWriter writer = new PrintWriter(System.out)) {
                summaryGeneratingListener.getSummary().printTo(writer);
            }
        }
    }
    </pre>
    <p>
        Теперь, если запустим main, то выполнятся только тесты, которые отмечены как login:
    </p>
    <img src="ju-9-1.png" alt="ju-9-1" width="30%">
    <p>
        Если обратимся к <code>.excludeTags("login")</code>, то выполнятся все которые не помечены login:
    </p>
    <b>TestLauncher.java, main()</b>
    <pre>
        LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                .request()
//                Указываем, где наш request будет искать наши тесты
//                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                .filters(
                        TagFilter.excludeTags("login")
                )
                .build();
    </pre>
    <img src="ju-9-2.png" alt="ju-9-2" width="30%">
    <p>
        Если же хотим запустить через командную строку, то в maven есть специальная JVM опции, которые позволяют
        передавать флаги через флаг -D: <code>mvn clean test -Dgroups=login</code>:
    </p>
    <img src="ju-9-3.png" alt="ju-9-3" width="60%">
    <p>
        А чтобы исключить тег, передаём флаг <code>mvn clean test -DexcludedGroups=login</code>:
    </p>
    <img src="ju-9-4.png" alt="ju-9-4" width="60%">
    <p>
        Запустим только те тесты, которые помечены тегом fast: <code>mvn clean test -Dgroups=fast</code>
    </p>
    <img src="ju-9-5.png" alt="ju-9-5" width="60%">
</article>
<article>
    <h1>JUnit 5. 8. Testing exceptions</h1>
    <p>
        Посмотрим, как можем проверить исключительные ситуации. Т.е. когда мы в наших методах пробрасываем какие-то
        исключения и мы хотим их как-то отловить и протестировать. Это должно быть ожидаемое поведение, что приложение
        пробросит исключение.
    </p>
    <p>
        Например, у нас есть функция <code>login()</code> в <code>UserService</code> и напишем тест, который проверяет,
        что этот метод пробрасывает исключение, если к примеру передали null в username или password. В таком случае
        пишем:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        void throwExceptionIfUsernameOrPasswordIsNull() {
            try {
                userService.login(null, "some password");
    //            тест не прошёл
                fail("login should throw exception on null username");
            } catch (IllegalArgumentException ex) {
    //            тест прошел, если исключение отработало
                assertTrue(true);
            }
        }
    </pre>
    <p>
        Если зайдём в исходники ассертов, то в итоге, в конечном методе увидим именно пробрасывание исключений. Т.е.,
        все ассерты - это всего лишь пробрасывание исключений. Все эти исключения - это
        <code>AssertionFailedError</code>'ы которые наследуются от <code>AssertionError</code>, а они в свою очередь
        наследуются от обычного <code>Error</code>, который наследует <code>Throwable</code>.
    </p>
    <p>
        Теперь пишем функционал, в котором метод <code>login()</code> в <code>UserService</code> будет пробрасывать
        исключение:
    </p>
    <b>UserService.java</b>
    <pre>
    public Optional&lt;User> login(String username, String password) {
        if (username == null || password == null) {
            throw new IllegalArgumentException("username or password is null");
        }
        return users.stream()
                .filter(user -> user.getUsername().equals(username))
                .filter(user -> user.getPassword().equals(password))
                .findFirst();
    }
    </pre>
    <p>
        Запускаем тест и проверяем, что он проходит:
    </p>
    <img src="ju-8-1.png" alt="ju-8-1" width="30%">
    <p>
        Если бы мы хотели проверить несколько кейсов. Например, то, что передаём не только username null, а и password,
        то нам нужно было бы использовать ещё один try-catch либо второй тест писать, что не очень удобно. Хотелось
        бы что-то вроде ассертов как делали в случае проверки нашей Map и тогда в <code>assertAll</code> запихнули бы
        сразу два тест-кейса чтобы не плодить множество тест-методов. Как раз таки для этого есть специальный
        ассерт в JUnit 5 и этот ассерт называется <code>assertThrows()</code>, в который передаём исключение, которое
        ожидаем получить:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void throwExceptionIfUsernameOrPasswordIsNull() {
        assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
    }
    </pre>
    <p>
        Более того, т.к. теперь можем проверить два тест-кейса потому что это всего лишь один ассерт, то следственно
        можем написать <code>assertAll()</code>:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void throwExceptionIfUsernameOrPasswordIsNull() {
        assertAll(
                () -> assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password")),
                () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
        );
    }
    </pre>
    <p>
        Такой функционал был в последних версиях JUnit 4, но до него мы могли проверить тип исключения только при
        помощи аннотации <code>@org.junit.Test(excepted = Exception.class)</code>. В нашем случае, если делаем
        <code>assertThrows</code>, то он ещё и возвращает исключение и можем дальше проверять его. Например, проверием
        исключение на сообщение:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void throwExceptionIfUsernameOrPasswordIsNull() {
        assertAll(
                () -> {
                    IllegalArgumentException argumentException = assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
                    assertThat(argumentException.getMessage()).isEqualTo("username or password is null");
                },
                () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
        );
    }
    </pre>
</article>
<article>
    <h1>JUnit 5. 7. AssertJ & Hamcrest</h1>
    <p>
        Существуют дополнительные библиотеки которые можем подключать в наш проект и предоставлять более обширный
        API для наших ассертов. Это <b>AssertJ</b> & <b>Hamcrest</b>. Разберёмся с каждой из них.
    </p>
    <h2>AssertJ</h2>
    <pre>
        &lt;dependency>
            &lt;groupId>org.assertj&lt;/groupId>
            &lt;artifactId>assertj-core&lt;/artifactId>
            &lt;version>3.19.0&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
    <p>
        Переходим в <code>UserServiceTest</code> и к примеру заменим <code>assertEquals</code> на метод из assertj.
        Все AssertJ и Hamcrest имеют следующий функционал: вместо <code>assertEquals()</code>,
        <code>assertFalse()</code> и т.д. - они используют <code>asThat</code> и смысл в том, что передаём туда
        значение,
        которое в дальнейшем будем сравнивать (т.е. передаем сразу актуальное значение, которое будем тестировать).
        И далее, после того как передали в <code>.assertThat()</code>, мы уже можем вызывать невероятно большое
        кол-во проверок (т.е. сравнение актуального значения с каким-то ожидаемым):
    </p>
    <img src="ju-7-1.png" alt="ju-7-1" width="60%">
    <p>
        В нашем случае, когда нужно сравнивать размер - обращаемся к методу <code>.hasSize()</code>.
    </p>
    <pre>
        assertThat(users).hasSize(2);
    </pre>
    <p>
        Т.е. проверяем, что размер списка пользователей равен двум. То же самое и с Optional'ами:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }
    </pre>
    <p>
        Так же в нем удобно тестировать такие коллекции как Map. Например, сделаем метод в <code>UserService</code>,
        который возвращает <code>Map</code> пользователей, где ключом является их ID (предварительно немного
        поменяем метод <code>add()</code> в <code>UserService</code>:
    </p>
    <pre>
    package com.kainv.service;

    import com.kainv.dto.User;

    import java.util.*;

    import static java.util.function.Function.identity;
    import static java.util.stream.Collectors.toMap;

    public class UserService {

        private final List&lt;User> users = new ArrayList&lt;>();

        public List&lt;User> getAll() {
            return users;
        }

        public void add(User... users) {
            this.users.addAll(Arrays.asList(users));
        }

        public Optional&lt;User> login(String username, String password) {
            return users.stream()
                    .filter(user -> user.getUsername().equals(username))
                    .filter(user -> user.getPassword().equals(password))
                    .findFirst();
        }

        public Map&lt;Integer, User> getAllConvertedById() {
            return users.stream().collect(toMap(User::getId, identity()));
        }
    }

    </pre>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Map;
    import java.util.Optional;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertThat(users).hasSize(2);
    //        assertEquals(2, users.size());
        }

        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void usersConvertedToMapById() {
            userService.add(VADIM, PETR);

            Map&lt;Integer, User> users = userService.getAllConvertedById();


            assertAll(
                    () ->
                            // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                            assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                    () ->
                            // Проверяем Map не только на содержание, но и значений
                            assertThat(users).containsValues(VADIM, PETR)
            );

        }

        @Test
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }

    </pre>
    <p>
        Используем <code>assertAll()</code> чтобы все ассерт проверились (потому что если один ассерт провалится, то
        дальше ассерты не будут провериться).
    </p>
    <p>
        Запускаем тесты и проверяем, что наш функционал работает:
    </p>
    <img src="ju-7-2.png" alt="ju-7-2" width="30%">
    <h2>Hamcrest</h2>
    <p>
        Эта библиотека была как транзитивная зависимость в JUnit 4. Подключим его и увидим, что подтягивается
        зависимость. Но в транзитивной зависимости этого недостаточно. Поэтому подключаем дополнительную зависимость:
    </p>
    <pre>
        &lt;dependency>
            &lt;groupId>junit&lt;/groupId>
            &lt;artifactId>junit&lt;/artifactId>
            &lt;version>4.13.1&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
        &lt;dependency>
            &lt;groupId>org.hamcrest&lt;/groupId>
            &lt;artifactId>hamcrest-all&lt;/artifactId>
            &lt;version>1.3&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
    <p>
        В этом случае у нас будет гораздо больше всяких matcher'ов которые можем использовать, для того чтобы работать
        с коллекциями как делаем это в assertj. Только исключим hamcrest, который пришел из junit 4:
    </p>
    <pre>
        &lt;dependency>
            &lt;groupId>junit&lt;/groupId>
            &lt;artifactId>junit&lt;/artifactId>
            &lt;version>4.13.1&lt;/version>
            &lt;scope>test&lt;/scope>
            &lt;exclusions>
                &lt;exclusion>
                    &lt;groupId>org.hamcrest&lt;/groupId>
                    &lt;artifactId>hamcrest-core&lt;/artifactId>
                &lt;/exclusion>
            &lt;/exclusions>
        &lt;/dependency>
        &lt;dependency>
            &lt;groupId>org.hamcrest&lt;/groupId>
            &lt;artifactId>hamcrest-all&lt;/artifactId>
            &lt;version>1.3&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
    <p>
        Возвращаемся в UserServiceTest и смотрим как могли бы переписать <code>usersConvertedToMapById()</code> на
        hamcrest. Он так же как и assertj использует <code>assertThat</code> функционал и в нем как и в случае
        junit передаётся два параметра: актуальное и ожидаемое:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void usersConvertedToMapById() {
        userService.add(VADIM, PETR);

        Map&lt;Integer, User> users = userService.getAllConvertedById();

        MatcherAssert.assertThat(users, IsMapContaining.hasKey(VADIM.getId()));

        assertAll(
                () ->
                        // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                        assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                () ->
                        // Проверяем Map не только на содержание, но и значений
                        assertThat(users).containsValues(VADIM, PETR)
        );
    }
    </pre>
    <pre>
    @Test
    void usersEmptyIfNoUserAdded() {
        System.out.println("Test 1: " + this);

        List&lt;User> users = userService.getAll();

        MatcherAssert.assertThat(users, IsEmptyCollection.empty());
        assertTrue(users.isEmpty(), () -> "User list should be empty");
    }
    </pre>
    <p>
        Т.е. суть в том, что у нас есть множество всяких метчеров и они передаются как вторым параметром.
    </p>
</article>
<article>
    <h1>JUnit 5. 6. Test Driven Development. TDD</h1>
    <img src="ju-6-1.png" alt="ju-6-1" width="30%">
    <p>
        Суть её в том, что в процессе разработки ПО мы сначала пишем тесты, а за тем уже основной функционал, который
        покрываем этими тестами. Этот процесс можно разбить на шаги:
    </p>
    <ol>
        <li>
            Добавить тест на новую функциональность.
        </li>
        <li>
            Запустить тест. Естественно, вначале не получится запустить потому что будет ошибки компиляции. В итоге
            увидим, что тест не прошёл.
        </li>
        <li>
            Пишем код, чтобы тест прошёл
        </li>
        <li>
            Убеждаемся, что все другие тесты прошли. Это важный шаг. Здесь также ключевую роль играет <b>регрессия</b>,
            т.е. проверка того, что мы не нарушили существующий код. Это потому что пишем не только новый функционал,
            но и также изменяем его. Следственно, чтобы не нарушить ничего нас и спасают наши тесты, которые писали до
            этого. Поэтому, в четвертом шаге убеждаемся, что они (тесты) так же прошли.
        </li>
        <li>
            После чего выполняем рефакторинг кода. Это тоже один из важных шагов потому что есть хороший принцип, что
            должны после себя оставить код лучше, чем когда в первый раз видели. Так же сюда можно отнести принцип
            разбитого окна (книга программист-прагматик).
        </li>
    </ol>
    <p>
        Если рассматривать упрощённую систему TDD, то получаются три главных шага:
    </p>
    <ol>
        <li>
            <b>RED</b>
        </li>
        <li>
            <b>GREEN</b>
        </li>
        <li>
            <b>REFACTOR</b>
        </li>
    </ol>
    <h2>На примере UserService реализуем TDD</h2>
    <p>
        Создадим функцию авторизации пользователя в системе. Первым тестом будет тест на успешную авторизацию, если
        пользователь существует. Помимо этого в pom.xml подключим зависимость к lombok.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Optional;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);
            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
    <p>
        Теперь реализовываем функционал для <code>userService.login()</code>:
    </p>
    <pre>
    package com.kainv.service;

    import com.kainv.dto.User;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Optional;

    public class UserService {

        private final List&lt;User> users = new ArrayList&lt;>();

        public List&lt;User> getAll() {
            return users;
        }

        public boolean add(User user) {
            return users.add(user);
        }

        public Optional&lt;User> login(String username, String password) {
            return users.stream()
                    .filter(user -> user.getUsername().equals(username))
                    .filter(user -> user.getPassword().equals(password))
                    .findFirst();
        }
    }
    </pre>
    <p>
        Запускаем тесты и проверяем:
    </p>
    <img src="ju-6-2.png" alt="ju-6-2" width="60%">
    <p>
        Видим, что тест прошел успешно. Мы не изменяли другие методы и следовательно, маловероятно, что мы могли что-то
        повредить. Тем не менее шанс есть. Продолжаем писать функционал: на случай, если пароль неправильный.
    </p>
    <p>
        И сделаем проверку, если пользователя не существует.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Optional;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }

    </pre>
    <p>
        В итоге получается, что мы сначала подготавливаем какие-то данные, вторым шагом делаем запрос на ту функцию,
        которую проверяем и третий шаг - добавляем <code>assert</code>'ы на то, что сделали.
    </p>
    <p>
        Проверим, что все тесты проходят:
    </p>
    <img src="ju-6-3.png" alt="ju-6-3" width="25%">
</article>
<article>
    <h1>JUnit 5. 5. Запуск тестов. Launcher API</h1>
    <h2>Разберёмся как удаётся запускать тесты</h2>
    <p>
        В Java есть один единственный метод main,
        который можем запускать в языке программирования Java. Отсюда можем видеть то, как устроен JUnit 5:
    </p>
    <img src="ju-5-1.png" alt="ju-5-1" width="45%">
    <p>
        Когда пишем наши тесты - мы используем <b><i>JUnit 5 API</i></b>, который в свою очередь разбит на подпроекты.
    </p>
    <p>
        В свою очередь для выполнения тестов нам нужен <b><i>JUnit Engine</i></b>, он транзитивной зависимостью
        предоставил JUnit 5 API.
    </p>
    <p>
        В свою очередь чтобы мы могли писать на разных версиях JUnit у нас есть общий API для всех test engine'ов,
        это <b><i>JUnit Engine API</i></b>. Он также является транзитивной зависимостью когда подключаем
        <i>JUnit Engine</i>. Эта платформа называется <i>junit-platform-engine</i>.
    </p>
    <p>
        Если посмотрим на подключенные зависимости, то увидим, что как только подключили <i>junit-jupiter-engine</i>,
        то подключились <i>junit-jupiter-api</i>, который используем для написания тестов и откуда у нас есть наши
        <code>Assertions</code>, аннотации т.д.. И в то же самое время видим <i>junit-platform-engine</i>, который
        представляет API (по сути набор классов и интерфейсов), которые уже реализуются нашим
        <i>junit-jupiter-engine</i>
        для того чтобы писать на JUnit 5. Если хотим писать на JUnit 4, то там уже будет свой engine либо можем написать
        даже кастомный engine и все это так же будет работать если будем использовать <i>junit-platform-engine</i>.
    </p>
    <img src="ju-5-2.png" alt="ju-5-2" width="30%">
    <p>
        В свою очередь, для запуска тестов мы используем инструменты (<b><i>Tools</i></b>). Все они используют
        <b><i>JUnit Launcher</i></b>. Мы можем подключить эту зависимость и с помощью её вызвать соответствующие
        <i>junit-platform-engine</i> и проверить наши тесты.
    </p>
    <h2>Подключим зависимость JUnit Launcher вручную</h2>
    <pre>
        &lt;dependencies>
            &lt;dependency>
                &lt;groupId>org.junit.jupiter&lt;/groupId>
                &lt;artifactId>junit-jupiter-engine&lt;/artifactId>
                &lt;version>5.8.0-M1&lt;/version>
                &lt;scope>test&lt;/scope>
            &lt;/dependency>
            &lt;dependency>
                &lt;groupId>org.junit.platform&lt;/groupId>
                &lt;artifactId>junit-platform-launcher&lt;/artifactId>
                &lt;version>1.8.0-M1&lt;/version>
                &lt;scope>test&lt;/scope>
            &lt;/dependency>
        &lt;/dependencies>
    </pre>
    <p>
        И напишем свой класс с методом <code>main</code>, который запускает наши тесты. В методе <code>main</code>
        нужно создать <code>Launcher</code>, его объект.
    </p>
    <pre>
    package com.kainv;

    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.core.LauncherFactory;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();
        }
    }
    </pre>
    <p>
        Дефолтный интерфейс <code>Launcher</code> содержит набор методов:
    </p>
    <img src="ju-5-3.png" alt="ju-5-3" width="30%">
    <ul>
        <li>
            <b>discover</b> - нужен, для того чтобы найти те методы, которые нужно запустить (т.е. наши тестовые
            методы).
        </li>
        <li>
            <b>execute</b> - нужен, для того чтобы запустить найденные тесты.
        </li>
        <li>
            <b>registerLauncherDiscoveryListeners</b> - отслеживает события когда находим какие-то тесты.
        </li>
        <li>
            <b>registerTestExecutionListeners</b> - отслеживают выполнения каждого из этих тестов.
        </li>
    </ul>
    <p>
        Также есть и <code>DefaultLauncher</code>, который возвращается когда ничего не передаём в метод
        <code>create()</code>.
    </p>
    <p>
        Далее, можем вызвать <code>execute()</code> и выполнить тесты. В нём есть два перегруженных метода:
        <code>TestPlan</code> (он и является основным) и <code>LauncherDiscoveryRequest</code>, который в
        последующем оборачивается в <code>TestPlan</code>. В нашем случае создадим request при помощи объекта
        <code>LauncherDiscoveryRequest</code> (можно и через <code>launcher.registerLauncherDiscoveryListeners()</code>):
    </p>
    <pre>
    package com.kainv.junit;

    import org.junit.platform.engine.discovery.DiscoverySelectors;
    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.LauncherDiscoveryRequest;
    import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
    import org.junit.platform.launcher.core.LauncherFactory;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .build();
        }
    }
    </pre>
    <p>
        Теперь, в <code>launcher.execute()</code> первым параметром передаём <code>request</code> и вторым параметром
        можем передать <code>TestExecutionListener</code> (также могли бы передать в
        <code>launcher.registerTestExecutionListeners();</code>). Эти листенеры как раз нужны, для того чтобы увидеть
        результат выполнения тестов потому что метод <code>execute()</code> возвращают <code>void</code>.
    </p>
    <pre>
    package com.kainv.junit;

    import org.junit.platform.engine.discovery.DiscoverySelectors;
    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.LauncherDiscoveryRequest;
    import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
    import org.junit.platform.launcher.core.LauncherFactory;
    import org.junit.platform.launcher.listeners.SummaryGeneratingListener;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();
    //        launcher.registerTestExecutionListeners();

            SummaryGeneratingListener summaryGeneratingListener = new SummaryGeneratingListener();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .build();

            launcher.execute(request, summaryGeneratingListener);
        }
    }
    </pre>
    <p>
        Следовательно, для того чтобы посмотреть нашу статистику, то у
        <code>summaryGeneratingListener.getSummary()</code>
        после выполнения есть куча методов. Можем воспользоваться <code>.printTo()</code>, который на вход принимает
        <code>PrintWriter</code> (а значит надо использовать try-with-resources):
    </p>
    <pre>
    package com.kainv.junit;

    import org.junit.platform.engine.discovery.DiscoverySelectors;
    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.LauncherDiscoveryRequest;
    import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
    import org.junit.platform.launcher.core.LauncherFactory;
    import org.junit.platform.launcher.listeners.SummaryGeneratingListener;

    import java.io.PrintWriter;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();
    //        launcher.registerTestExecutionListeners();

            SummaryGeneratingListener summaryGeneratingListener = new SummaryGeneratingListener();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .build();

            launcher.execute(request, summaryGeneratingListener);

    //          Выводим результат тестирования
            try (PrintWriter writer = new PrintWriter(System.out)) {
                summaryGeneratingListener.getSummary().printTo(writer);
            }
        }
    }
    </pre>
    <p>
        Запустим класс и посмотрим что выведет:
    </p>
    <img src="ju-5-4.png" alt="ju-5-4" width="30%">
    <p>
        Он обнаружил два теста, два теста запустились и эти два теста завершились успешно.
    </p>
    <br>
    <p>
        Зайдём в метод <code>execute()</code>, который выполняет наши тесты. Зайдём в <code>DefaultLauncher</code>.
        Когда получаем <code>DiscoveryRequest</code> - мы на основании его билдим тестовый план и все равно в итоге
        получаем реализацию класса <code>class InternalTestPlan extends TestPlan</code> (это общий объект, чтобы
        запускать наши тесты, он содержит все по состоянию наших тестов). (10:00) И далее, в
        <code>DefaultLauncher</code> когда выполняем <code>execute()</code> (переходим по нему) и видим, что из
        нашего <code>InternalTestPlan</code> берутся все листенеры, которые билдятся в методе
        <code>buildListenerRegistryForExecution</code> и если мы не передали в метод листенеры, то возвращаются те,
        которые были зарегистрированы во время создания лаунчера. В противном случае берём общую коллекцию с нашими
        листенерами которые зарегистрировали и + те, что передали в метод <code>execute</code>. Далее создаётся
        общий комбинированный листенер, в котором запускается метод <code>testPlanExecutionStarted</code> и
        <code>testPlanExecutionFinished</code> и во время него так же вызываются события нашего листенера. Т.е. только
        через листенер мы можем посмотреть что произошло во время выполнения тестов.
    </p>
    <p>
        Так же когда выполняем метод <code>create()</code>, то передаём дефолтный <code>LauncherConfig</code> для
        создания его и создаётся <code>createDefaultLauncher()</code> в котором собираются все тестовые engine'ы.
        В нам случае используются <code>TestEngine</code>. Это как раз относится к JUnit Engine API.
    </p>
</article>
<article>
    <h1>JUnit 5. 4. Test Lifecycle</h1>
    <p>
        Познакомимся с жизненным циклом тестов.
    </p>
    <img src="ju-4-1.png" alt="ju-4-1" width="45%">
    <p>
        Когда пишем тесты в нашем <code>UserServiceTest</code>, то в этом классе у нас может быть множество таких
        тестов. Мы просто пишем методы и помечаем их аннотациями <code>@Test</code>. Но также нам часто надо
        что-то предустановить и почистить после выполнения тестов. Следственно, для этого можем написать соответствующие
        методы и пометить их аннотациями:
    </p>
    <ul>
        <li>
            <code>@BeforeEach</code> - если хотим что-то предустановить перед тестами.
        </li>
        <li>
            <code>@AfterEach</code> - если хотим почистить после каждого теста.
        </li>
    </ul>
    <p>
        Следственно, сколько будет тестов в классе, столько раз будет происходить вызов цикла <code>@BeforeEach</code>
        -> <code>@Test</code> -> <code>@AfterEach</code>. Если что-то хотим предустановить перед всеми вызовами этих
        тестов и почистить после них, то для этого есть аннотации <code>@BeforeAll</code> и <code>@AfterAll</code>.
    </p>
    <p>
        Отсюда получается жизненный цикл: сначала вызывается <code>@BeforeAll</code> перед всеми тестами ->
        далее происходит вызов всех наших тестов по циклу, при чем порядок не гарантирован. <b>Не следует</b> писать
        тесты полагаясь на вызов других тестов, наши тесты <b>должны быть</b> независимы друг от друга. Поэтому
        происходит череда вызовов тестов и перед каждым тестом и после него вызывается <code>@BeforeEach</code> и
        <code>@AfterEach</code> секция. Как только все тесты были закончены, то происходит вызов <code>@AfterAll</code>.
    </p>
    <h2>Посмотрим как это работает на практике</h2>
    <p>
        Для этого создадим ещё один <code>@Test</code> на добавление в <code>UserService</code> наших пользователей
        (заранее реализовать метод <code>add()</code> в <code>UserService</code>):
    </p>
    <pre>
    package com.kainv.service;
    
    import com.kainv.dto.User;
    
    import java.util.ArrayList;
    import java.util.List;
    
    public class UserService {
        
        private final List&lt;User> users = new ArrayList&lt;>();
        
        public List&lt;User> getAll() {
            return users;
        }
    
        public boolean add(User user) {
            return users.add(user);
        }
    }
    </pre>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            UserService userService = new UserService();
            userService.add(new User);
            userService.add(new User);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }
    }
    </pre>
    <p>
        И вызовем тесты:
    </p>
    <img src="ju-4-2.png" alt="ju-4-2" width="45%">
    <p>
        Теперь используем <code>@BeforeEach</code>. Т.е. перед тем как выполняются все наши тесты, я хочу что-то
        подготовить. Т.к. у нас два раза повторяется инициализация <code>UserService</code> в тест-методах, то значит,
        что можем эту инициализацию вынести в метод с аннотацией <code>@BeforeEach</code>.
    </p>
    <p>
        Так же создаём <code>@AfterEach</code> в котором выполняем какую-нибудь очистку. Например, данные из баз данных
        если в наших тестах делаем какие-то insert'ы и прочее для того чтобы следующий тест независил от этих данных.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.AfterEach;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {

        private UserService userService;

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(new User());
            userService.add(new User());

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }
    }
    </pre>
    <p>
        Теперь запустим и проверим что у нас получится:
    </p>
    <img src="ju-4-3.png" alt="ju-4-3" width="70%">
    <p>
        Видим, что выполнилось оба теста на каждом из которых сработали <code>@BeforeEach</code> и
        <code>@AfterEach</code>. Более того, toString отличается у нашего объекта <code>UserServiceTest</code>.
        Следовательно, у нас выходит новое <b>правило</b>, что по умолчанию каждый раз создается новый объект
        <code>UserServiceTest</code> и в нем вызываются соответсвующее методы <code>@BeforeEach</code>, выполняется
        тест и вызывается <code>@AfterEach</code>. Так будет после каждого метода. Это безопасно для нас чтобы не
        изменялось состояние наших объектов. В данном случае полей нашего класса <code>UserServiceTest</code>.
    </p>
    <p>
        Последнее это <code>@BeforeAll</code> & <code>@AfterAll</code>, где будет проходить инициализация для всех
        тестов происходить.
    </p>
    <p>
        Если попробуем запустить, то будет ошибка потому что методы <code>@BeforeAll</code> & <code>@AfterAll</code>
        должны быть <code>static</code>. По умолчанию у нас есть жизненный цикл наших тестов и можем его задавать
        через аннотацию <code>@TestInstance</code> и по умолчанию это
        <code>@TestInstance(TestInstance.Lifecycle.PER_METHOD)</code>. Т.е. каждый раз создаётся новая сущность
        <code>UserServiceTest</code> и вызывается <code>@BeforeEach</code> -> <code>@Test</code> ->
        <code>@AfterEach</code>. Следовательно, <code>@BeforeAll</code> & <code>@AfterAll</code> не могут быть не
        статическими потому что нужно как-то один раз вызвать перед тестами и один раз вызвать после всех тестов.
    </p>
    <p>
        Теперь можем запустить тесты и все будет работать:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_METHOD)
    class UserServiceTest {

        private UserService userService;

        @BeforeAll
        static void init() {
            System.out.println("Before all");
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(new User());
            userService.add(new User());

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        static void closeConnectionPool() {
            System.out.println("After all");
        }
    }
    </pre>
    <img src="ju-4-4.png" alt="ju-4-4" width="70%">
    <p>
        Но если сделаем <code>TestInstance.Lifecycle.PER_CLASS</code>, то уже нет необходимости делать
        <code>static</code> потому что тогда и так создаем лишь один объект <code>UserServiceTest</code> для
        всех тестов.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    class UserServiceTest {

        private UserService userService;

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(new User());
            userService.add(new User());

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
    <img src="ju-4-5.png" alt="ju-4-5" width="70%">
    <p>
        Видим, что теперь везде одинаковые ссылки.
    </p>
</article>
<article>
    <h1>JUnit 5. 3. Аннотация @Test. Assertions</h1>
    <p>
        Разберёмся как написать тест, общие концепции написания тестов и нейминг конвенции.
    </p>
    <p>
        Для начала, все наши тесты должны быть в директории src/test/java. Т.е. используем maven или gradle (неважно,
        поскольку используют одну структуру проектов). Например, если написали <code>UserServiceTest</code>, то это
        означает, что мы тестируем <code>UserService</code> класс и этот тест находится в той же самой директории, что
        и исходник. Используем постфикс Test потому что используем surefire-plugin, который занимается тем, что
        запускает тесты. Он отслеживает только те классы в директории test, которые заканчиваются на определенный
        постфикс или префикс. Префиксальный вариант не особо предпочтительный, зато постфиксный по умолчанию это
        <code>Test</code>, <code>Tests</code>, <code>Testcase</code>.
    </p>
    <p>
        Далее, сами классы и тесты должны в JUnit 4 должны были быть <code>public</code>, но в JUnit 5 такое не
        надо, поэтому убираем эту конструкцию с классов и тестов:
    </p>
    <pre>
    package com.kainv.junit.service;

    import org.junit.jupiter.api.Test;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void test() {
            assertTrue(false);
        }
    }
    </pre>
    <p>
        Теперь поговорим об именовании тестов. До того как появилась аннотация <code>@Test</code>, все тесты имели
        префикс Test потому что инструменты для запуска этих тестов (например surefire-plugin) отслеживал именование
        методов и по префиксу запускал те методы, которые начинаются с Test. В JUnit 5 появилась аннотация
        <code>@Test</code>, которая позволила запускать эти тесты невзирая на именование. Следовательно, теперь
        только те тесты, которые обозначены аннотацией <code>@Test</code> запускается нашим плагином. Если
        перейдём в исходники аннотации, то увидим, что её можно ставить над методами и аннотациями которые хотим
        запустить для теста:
    </p>
    <img src="ju-3-1.png" alt="ju-3-1" width="45%">
    <p>
        Мета-аннотация <code>@Testable</code> которая используется jupiter test engine просто в качестве
        мета-информации чтобы отслеживать функционал который можем запустить в качестве тестов.
    </p>
    <p>
        Создадим экземпляр класса <code>UserService</code> и вызовем метод <code>getAll()</code> (предварительно
        создав в src/java/main):
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void test() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty());
        }
    }
    </pre>
    <p>
        Мы сначала написали тест, а потом функционал. Такая методология называется <b>TTD (Test Driven
        Development)</b>.
    </p>
    <p>
        В нашем тесте проверяем, что получаем всех наших пользователей и наша коллекция будет пустая если туда
        ничего не положили. Теперь можем именовать наш <code>void test</code>. Название теста должно полностью
        отображать что у нас происходит в тесте. Так как это юнит-тест, он проверяет всего лишь маленький функционал,
        метод один единственный в одном единственном классе. В нашем случае получается:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty());
        }
    }
    </pre>
    <p>
        В именовании можем использовать как SnakeCase так и CamelCase без префиксов и постфиксов, т.к. уже стоит
        аннотация <code>@Test</code>.
    </p>
    <p>
        Запустим тест и проверим, что он работает: <code>mvn test</code>
    </p>
    <img src="ju-3-2.png" alt="ju-3-2" width="25%">
    <p>
        Видим, что тест успешно запустился и отработал.
    </p>
    <p>
        Класс <code>Assertions</code> необходим для того, чтобы проверять ожидаемое и актуальное значение, которое
        получили из функций. По сути, всегда в наших тестов подаём на вход input в "черный ящик" Input -> [box == func]
        ->
        actual output и на выходе получаем актуальные значения. В данном случае <code>assertTrue</code> принимает
        условие и если он true, то тест пройден, иначе тест проваливается. С помощью таких assert'ов происходят наши
        проверки на ожидаемые и актуальные значения. Так же можно использовать <code>assertFalse</code>:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertFalse(users.isEmpty());
        }
    }
    </pre>
    <img src="ju-3-3.png" alt="ju-3-3" width="70%">
    <p>
        Получаем Test failed и где этот тест зафейлился, в каком методе, каком классе, что ожидали получить и
        актуальное значение. Так будет всегда: подаём что-то на вход, вызываем функцию и проверяем ожидаемое и
        актуальное значение при помощи <code>assertFalse</code>. Также можем вторым параметром передавать более
        подробное описание ошибки:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertFalse(users.isEmpty(), () -> "User list should be empty");
        }
    }
    </pre>
    <img src="ju-3-4.png" alt="ju-3-4" width="70%">
    <p>
        В <code>assertEquals</code> мы можем передавать ожидаемые и актуальные данные и они должны совпасть.
    </p>
    <p>
        <code>assertThrows</code> проверяет пробрасывает ли метод какой-то exception.
    </p>
    <p>
        <code>assertAll</code> нужен когда есть несколько assert'ов в нашем методе потому что по best practice было
        бы неплохо иметь один assert в рамках одного теста потому что если зафейлится тест на строчке 13 а после него
        был ещё один assert, то мы до него даже не дойдем. Поэтому <code>assertAll</code> прекрасный вариант чтобы
        вызывать сразу несколько assert'ов и получить результат по всем из них.
    </p>
    <p>
        <code>assertArrayEquals</code> тоже самое что и <code>assertEquals</code> только проверяет массивы.
    </p>
    <p>
        И много других assert'ов. По-хорошему их все равно недостаточно поэтому так как JUnit разбит на модули и
        предполагает нам альтернативы - мы можем подключить дополнительные библиотеки для наших assert'ов (например
        AssertJ, Hamcrest).
    </p>
</article>
<article>
    <h1>JUnit 5. 2. Установка программного обеспечения</h1>
    <p>
        В качестве линковщика будем использовать maven. Подключим зависимости для JUnit 5 в pom:
    </p>
    <pre>
    &lt;dependencies>
        &lt;dependency>
          &lt;groupId>org.junit.jupiter&lt;/groupId>
          &lt;artifactId>junit-jupiter-engine&lt;/artifactId>
          &lt;version>5.8.0-M1&lt;/version>
          &lt;scope>test&lt;/scope>
        &lt;/dependency>
    &lt;/dependencies>
    </pre>
    <p>
        В test/java/com/kainv/junit/service класс UserService:
    </p>
    <pre>
package com.kainv.junit.service;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class UserService {
    @Test
    void test() {
        assertTrue(false);
    }
}
    </pre>
    <p>
        И выполним <code>mvn test</code>. И увидим проблемы:
    </p>
    <img src="ju-2-1.png" alt="ju-2-1" width="45%">
    <p>
        Во первых надо переопределить maven-compiler-plugin потому что JUnit использует версию 8 или выше. Во вторых
        надо будет переопределить surefire-plugin до новой версии.
    </p>
    <pre>
  &lt;build>
    &lt;plugins>
      &lt;plugin>
        &lt;groupId>org.apache.maven.plugins&lt;/groupId>
        &lt;artifactId>maven-compiler-plugin&lt;/artifactId>
        &lt;version>3.8.1&lt;/version>
        &lt;configuration>
            &lt;source>15&lt;/source>
            &lt;target>15&lt;/target>
        &lt;/configuration>
      &lt;/plugin>
      
      &lt;plugin>
        &lt;groupId>org.apache.maven.plugins&lt;/groupId>
        &lt;artifactId>maven-surefire-plugin&lt;/artifactId>
        &lt;version>2.22.2&lt;/version>
      &lt;/plugin>
    &lt;/plugins>
  &lt;/build>
    </pre>
    <p>
        Обновляем и выполняем <code>mvn test</code>. Проект сбилдился, но тесты не выполнились потому что наш
        тест-класс не с постфиксом <code>Test</code> (это дефолтное определение, наши тесты должны иметь определённый
        префиксы либо суффиксы). Поправим <code>UserService</code> на <code>UserServiceTest</code> и запустим:
    </p>
    <img src="ju-2-2.png" alt="ju-2-2" width="45%">
    <p>
        Видим, что тест провалился потому что у нас нет такого класса в main.
    </p>
    <p>
        Если хотим из командной строки запустить, то необходим wrapper. В командной строке вводим
        <code>mvn -N io.takari:maven:0.7.7:wrapper -Dmaven=3.6.3</code>. Получаем директорию .mvn где находится наш
        maven-wrapper. Более того, можем изменять наши пути к нужным нам установочникам в <i>.properties</i>.
        Теперь у нас есть файл <i>mvnw</i> & <i>mvnw.cmd</i> и использовать команду не <code>mvn</code>, а
        <code>./mvnw ...</code>.
    </p>
    <img src="ju-2-3.png" alt="ju-2-3" width="45%">
    <p>
        Теперь проект можно запускать как из IDE, так и из командной строки.
    </p>
</article>
<article>
    <h1>JUnit 5. 1. Введение</h1>
    <p>
        <b>Тестирование ПО</b> - это процесс испытания программы, целью которого является определить соответствие
        между <b>ожидаемым</b> поведением и <b>актуальным</b> с помощью набора тестов.
    </p>
    <img src="ju-1-1.png" alt="ju-1-1" width="45%">
    <p>
        Т.е. у нас есть какое-то приложение и, для того чтобы взаимодействовать с этим приложением - мы посылаем туда
        какие-то данные. Наше приложение обрабатывает эти данные и на выходе даёт результат input/output. И цель наших
        тестов как раз таки проверить этот актуальный результат с ожидаемым. И если они не совпадают друг с другом,
        следовательно, тесты нашли какой-то дефект в приложении. Поэтому именно такой подход всегда встречаем в
        тестировании.
    </p>
    <p>
        Тестирование необходимо не только, для того чтобы проверять новый функционал, но и для проверки
        работоспособности старого (<b>регрессионное тестирование</b>). Потому что в реальных приложениях чаще
        всего изменяется существующий функционал и велика вероятность изменения какого-то нового функционала
        при изменении другого. В этом и опасность изменений в существующем приложении. В этом случае нам помогут
        тесты.
    </p>
    <p>
        Выделяют следующие уровни тестирования:
    </p>
    <ol>
        <li>
            <b>Unit testing</b> - тестирование маленького компонента приложения (функции), т.е. этот <b>unit</b>
            должен правильно отрабатывать в изоляции от других компонентов.
            <br>
            <img src="ju-1-2.png" alt="ju-1-2" width="45%">
            <br>
            Т.е. этот юнит должен правильно отрабатывать в изоляции от других компонентов. Берём ту же самую модель,
            набор тестов, но в данном случае тестируем лишь одну какую-ту функцию в одном каком-то java-классе.
            Так же даём какой-то набор входных параметров (input) и функция возвращает какой-то результат
            (Actual output) и сверяем с ожидаемым результатом.
        </li>
        <li>
            <b>Integration testing</b> - интеграционное тестирование, тестирование несколько компонентов приложения
            (функций), т.е. как маленькие units работают вместе как один большой unit.
            <br>
            <img src="ju-1-3.png" alt="ju-1-3" width="45%">
            <br>
            Т.е. как маленькие юниты работают как один большой unit. Берём уже несколько таких функций, которые
            взаимодействуют друг с другом как одно целое и также в случае наших тестов - мы отправляем на вход
            большого юнита какие-то параметры и на выходе получаем какой-то ожидаемый результат. Мы опять же
            проверяем output актуальный с ожидаемым.
            <br>
            В java это будет выглядеть как набор классов и функций, которые просто вызывают друг друга.
        </li>
        <li>
            <b>Acceptance testing</b> - тестирование всего приложения в целом, т.е. как оно работает со стороны
            пользователя (функциональное тестирование).
            <br>
            <img src="ju-1-4.png" alt="ju-1-4" width="45%">
            <br>
            В этом случае нашим "черным ящиком" выступает всё приложение. Тестирование по сути эмулирует работу
            пользователей, которые работают с приложением. Они опять же посылают какие-то входные параметры и
            приложение отвечают им в виде output и сверяем его с ожидаемым поведением и если он не совпал, то
            тестирование выявляет какие-то дефекты приложения.
        </li>
    </ol>
    <img src="ju-1-5.png" alt="ju-1-5" width="45%">
    <p>
        Если посмотрим на эту диаграмму, то увидим, что Unit-тестов должно быть больше всего в нашем приложении
        потому что они простые и проверяют очень простой функционал.
    </p>
    <p>
        Интеграционных тестов должно быть меньше потому что они уже проверяют взаимодействие отдельных юнитов в
        нашем приложении и как они взаимодействуют друг с другом (например когда на вход одного сервиса передаём
        параметры, а он в свою очередь вызывает другие сервисы для получения выходного значения из своей функции).
    </p>
    <p>
        В случае acceptance тестов их должно быть ещё меньше потому что они самые сложные и проверяют всё приложение,
        весь функционал от начала до конца.
    </p>
    <p>
        Естественно, чем проще тест тем быстрее он запускается и быстрее отрабатывает. Чем сложнее тест, тем работает
        медленнее. Поэтому в нашем случае acceptance тесты медленее всего, а юнит-тесты быстрее всех. Чем раньше
        найдём какой-то дефект с помощью тестов тем дешевле обойдётся компании исправить эту проблему.
    </p>
    <p>
        <b>JUnit 5</b> - это один из самых распространенных Java-фреймворков, который предназначен для написания
        в основном Unit и Integration тестов. Для написания Acceptance тестов обычно используются другие тест
        фреймворки, например: <b>JBehave</b>, TestNG.
    </p>
    <p>
        JUnit 5 разбит на несколько основных под-проектов. Эти подпроекты в свою очередь разбиты на отдельные
        модули и подключаем только то, что нам необходимо:
    </p>
    <ul>
        <li>
            <b>JUnit Platform</b> - этот подпроект необходим для того чтобы была возможность запускать тесты на JVM.
            Более того, в нем есть функционал для запуска JUnit тестов на любых фреймворках (даже из консоли) и
            интеграция с такими build-инструментами как maven и gradle.
        </li>
        <li>
            <b>JUnit Jupiter</b> - этот подпроект предоставляет набор классов, которые разработчики используют для
            написания тестов. Т.е. различные API.
        </li>
        <li>
            <b>JUnit Vintage</b> - создан специально для интеграции с предыдущими версиями JUnit в случае если захотим
            использовать в своем приложении. Т.е. что-то вроде обратной совместимости с предыдущей версией JUnit 5.
        </li>
    </ul>
    <p>
        Обязательным требованием для JUnit 5 является наличие Java выше 8й версии.
    </p>
    <p>
        Наличие тестов в программе невероятно важный аспект в любом современном приложении на Java.
    </p>
</article>
</body>
</html>