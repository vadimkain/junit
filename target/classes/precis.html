<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Конспект jUnit</title>
</head>
<style>
    body {
        max-width: 80%;
        min-height: 400vh;
        margin-left: 5%;
        text-align: justify;
        font-family: Arial, sans-serif;
    }

    article {
        /*background: wheat;*/
        border-left: solid 5px #24b8ff;
        padding-left: 5%;
        margin-top: 5%;
        margin-bottom: 5%;
    }

    pre {
        /*font-size: 15px;*/
        /*font-weight: bold;*/
        background: rgba(179, 194, 245, 0.18);
    }

    code {
        font-size: 15px;
        font-weight: bold;
        background: rgba(179, 194, 245, 0.18);
    }

    li {
        margin-top: 1%;
        margin-bottom: 1%;
    }
</style>
<body>
<article>
    <h1>JUnit 5. 3. Аннотация @Test. Assertions</h1>
    <p>
        Разберёмся как написать тест, общие концепции написания тестов и нейминг конвенции.
    </p>
    <p>
        Для начала, все наши тесты должны быть в директории src/test/java. Т.е. используем maven или gradle (неважно,
        поскольку используют одну структуру проектов). Например, если написали <code>UserServiceTest</code>, то это
        означает, что мы тестируем <code>UserService</code> класс и этот тест находится в той же самой директории, что
        и исходник. Используем постфикс Test потому что используем surefire-plugin, который занимается тем, что
        запускает тесты. Он отслеживает только те классы в директории test, которые заканчиваются на определенный
        постфикс или префикс. Префиксальный вариант не особо предпочтительный, зато постфиксный по умолчанию это
        <code>Test</code>, <code>Tests</code>, <code>Testcase</code>.
    </p>
    <p>
        Далее, сами классы и тесты должны в JUnit 4 должны были быть <code>public</code>, но в JUnit 5 такое не
        надо, поэтому убираем эту конструкцию с классов и тестов:
    </p>
    <pre>
    package com.kainv.junit.service;

    import org.junit.jupiter.api.Test;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void test() {
            assertTrue(false);
        }
    }
    </pre>
    <p>
        Теперь поговорим об именовании тестов. До того как появилась аннотация <code>@Test</code>, все тесты имели
        префикс Test потому что инструменты для запуска этих тестов (например surefire-plugin) отслеживал именование
        методов и по префиксу запускал те методы, которые начинаются с Test. В JUnit 5 появилась аннотация
        <code>@Test</code>, которая позволила запускать эти тесты невзирая на именование. Следовательно, теперь
        только те тесты, которые обозначены аннотацией <code>@Test</code> запускается нашим плагином. Если
        перейдём в исходники аннотации, то увидим, что её можно ставить над методами и аннотациями которые хотим
        запустить для теста:
    </p>
    <img src="ju-3-1.png" alt="ju-3-1" width="45%">
    <p>
        Мета-аннотация <code>@Testable</code> которая используется jupiter test engine просто в качестве
        мета-информации чтобы отслеживать функционал который можем запустить в качестве тестов.
    </p>
    <p>
        Создадим экземпляр класса <code>UserService</code> и вызовем метод <code>getAll()</code> (предварительно
        создав в src/java/main):
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void test() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty());
        }
    }
    </pre>
    <p>
        Мы сначала написали тест, а потом функционал. Такая методология называется  <b>TTD (Test Driven
        Development)</b>.
    </p>
    <p>
        В нашем тесте проверяем, что получаем всех наших пользователей и наша коллекция будет пустая если туда
        ничего не положили. Теперь можем именовать наш <code>void test</code>. Название теста должно полностью
        отображать что у нас происходит в тесте. Так как это юнит-тест, он проверяет всего лишь маленький функционал,
        метод один единственный в одном единственном классе. В нашем случае получается:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty());
        }
    }
    </pre>
    <p>
        В именовании можем использовать как SnakeCase так и CamelCase без префиксов и постфиксов, т.к. уже стоит
        аннотация <code>@Test</code>.
    </p>
    <p>
        Запустим тест и проверим, что он работает: <code>mvn test</code>
    </p>
    <img src="ju-3-2.png" alt="ju-3-2" width="25%">
    <p>
        Видим, что тест успешно запустился и отработал.
    </p>
    <p>
        Класс <code>Assertions</code> необходим для того, чтобы проверять ожидаемое и актуальное значение, которое
        получили из функций. По сути, всегда в наших тестов подаём на вход input в "черный ящик" Input -> [box == func] ->
        actual output и на выходе получаем актуальные значения. В данном случае <code>assertTrue</code> принимает
        условие и если он true, то тест пройден, иначе тест проваливается. С помощью таких assert'ов происходят наши
        проверки на ожидаемые и актуальные значения. Так же можно использовать <code>assertFalse</code>:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertFalse(users.isEmpty());
        }
    }
    </pre>
    <img src="ju-3-3.png" alt="ju-3-3" width="70%">
    <p>
        Получаем Test failed и где этот тест зафейлился, в каком методе, каком классе, что ожидали получить и
        актуальное значение. Так будет всегда: подаём что-то на вход, вызываем функцию и проверяем ожидаемое и
        актуальное значение при помощи <code>assertFalse</code>. Также можем вторым параметром передавать более
        подробное описание ошибки:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertFalse(users.isEmpty(), () -> "User list should be empty");
        }
    }
    </pre>

</article>
<article>
    <h1>JUnit 5. 2. Установка программного обеспечения</h1>
    <p>
        В качестве линковщика будем использовать maven. Подключим зависимости для JUnit 5 в pom:
    </p>
    <pre>
    &lt;dependencies>
        &lt;dependency>
          &lt;groupId>org.junit.jupiter&lt;/groupId>
          &lt;artifactId>junit-jupiter-engine&lt;/artifactId>
          &lt;version>5.8.0-M1&lt;/version>
          &lt;scope>test&lt;/scope>
        &lt;/dependency>
    &lt;/dependencies>
    </pre>
    <p>
        В test/java/com/kainv/junit/service класс UserService:
    </p>
    <pre>
package com.kainv.junit.service;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class UserService {
    @Test
    void test() {
        assertTrue(false);
    }
}
    </pre>
    <p>
        И выполним <code>mvn test</code>. И увидим проблемы:
    </p>
    <img src="ju-2-1.png" alt="ju-2-1" width="45%">
    <p>
        Во первых надо переопределить maven-compiler-plugin потому что JUnit использует версию 8 или выше. Во вторых
        надо будет переопределить surefire-plugin до новой версии.
    </p>
    <pre>
  &lt;build>
    &lt;plugins>
      &lt;plugin>
        &lt;groupId>org.apache.maven.plugins&lt;/groupId>
        &lt;artifactId>maven-compiler-plugin&lt;/artifactId>
        &lt;version>3.8.1&lt;/version>
        &lt;configuration>
            &lt;source>15&lt;/source>
            &lt;target>15&lt;/target>
        &lt;/configuration>
      &lt;/plugin>
      
      &lt;plugin>
        &lt;groupId>org.apache.maven.plugins&lt;/groupId>
        &lt;artifactId>maven-surefire-plugin&lt;/artifactId>
        &lt;version>2.22.2&lt;/version>
      &lt;/plugin>
    &lt;/plugins>
  &lt;/build>
    </pre>
    <p>
        Обновляем и выполняем <code>mvn test</code>. Проект сбилдился, но тесты не выполнились потому что наш
        тест-класс не с постфиксом <code>Test</code> (это дефолтное определение, наши тесты должны иметь определённый
        префиксы либо суффиксы). Поправим <code>UserService</code> на <code>UserServiceTest</code> и запустим:
    </p>
    <img src="ju-2-2.png" alt="ju-2-2" width="45%">
    <p>
        Видим, что тест провалился потому что у нас нет такого класса в main.
    </p>
    <p>
        Если хотим из командной строки запустить, то необходим wrapper. В командной строке вводим
        <code>mvn -N io.takari:maven:0.7.7:wrapper -Dmaven=3.6.3</code>. Получаем директорию .mvn где находится наш
        maven-wrapper. Более того, можем изменять наши пути к нужным нам установочникам в <i>.properties</i>.
        Теперь у нас есть файл <i>mvnw</i> & <i>mvnw.cmd</i> и использовать команду не <code>mvn</code>, а
        <code>./mvnw ...</code>.
    </p>
    <img src="ju-2-3.png" alt="ju-2-3" width="45%">
    <p>
        Теперь проект можно запускать как из IDE, так и из командной строки.
    </p>
</article>
<article>
    <h1>JUnit 5. 1. Введение</h1>
    <p>
        <b>Тестирование ПО</b> - это процесс испытания программы, целью которого является определить соответствие
        между <b>ожидаемым</b> поведением и <b>актуальным</b> с помощью набора тестов.
    </p>
    <img src="ju-1-1.png" alt="ju-1-1" width="45%">
    <p>
        Т.е. у нас есть какое-то приложение и, для того чтобы взаимодействовать с этим приложением - мы посылаем туда
        какие-то данные. Наше приложение обрабатывает эти данные и на выходе даёт результат input/output. И цель наших
        тестов как раз таки проверить этот актуальный результат с ожидаемым. И если они не совпадают друг с другом,
        следовательно, тесты нашли какой-то дефект в приложении. Поэтому именно такой подход всегда встречаем в
        тестировании.
    </p>
    <p>
        Тестирование необходимо не только, для того чтобы проверять новый функционал, но и для проверки
        работоспособности старого (<b>регрессионное тестирование</b>). Потому что в реальных приложениях чаще
        всего изменяется существующий функционал и велика вероятность изменения какого-то нового функционала
        при изменении другого. В этом и опасность изменений в существующем приложении. В этом случае нам помогут
        тесты.
    </p>
    <p>
        Выделяют следующие уровни тестирования:
    </p>
    <ol>
        <li>
            <b>Unit testing</b> - тестирование маленького компонента приложения (функции), т.е. этот <b>unit</b>
            должен правильно отрабатывать в изоляции от других компонентов.
            <br>
            <img src="ju-1-2.png" alt="ju-1-2" width="45%">
            <br>
            Т.е. этот юнит должен правильно отрабатывать в изоляции от других компонентов. Берём ту же самую модель,
            набор тестов, но в данном случае тестируем лишь одну какую-ту функцию в одном каком-то java-классе.
            Так же даём какой-то набор входных параметров (input) и функция возвращает какой-то результат
            (Actual output) и сверяем с ожидаемым результатом.
        </li>
        <li>
            <b>Integration testing</b> - интеграционное тестирование, тестирование несколько компонентов приложения
            (функций), т.е. как маленькие units работают вместе как один большой unit.
            <br>
            <img src="ju-1-3.png" alt="ju-1-3" width="45%">
            <br>
            Т.е. как маленькие юниты работают как один большой unit. Берём уже несколько таких функций, которые
            взаимодействуют друг с другом как одно целое и также в случае наших тестов - мы отправляем на вход
            большого юнита какие-то параметры и на выходе получаем какой-то ожидаемый результат. Мы опять же
            проверяем output актуальный с ожидаемым.
            <br>
            В java это будет выглядеть как набор классов и функций, которые просто вызывают друг друга.
        </li>
        <li>
            <b>Acceptance testing</b> - тестирование всего приложения в целом, т.е. как оно работает со стороны
            пользователя (функциональное тестирование).
            <br>
            <img src="ju-1-4.png" alt="ju-1-4" width="45%">
            <br>
            В этом случае нашим "черным ящиком" выступает всё приложение. Тестирование по сути эмулирует работу
            пользователей, которые работают с приложением. Они опять же посылают какие-то входные параметры и
            приложение отвечают им в виде output и сверяем его с ожидаемым поведением и если он не совпал, то
            тестирование выявляет какие-то дефекты приложения.
        </li>
    </ol>
    <img src="ju-1-5.png" alt="ju-1-5" width="45%">
    <p>
        Если посмотрим на эту диаграмму, то увидим, что Unit-тестов должно быть больше всего в нашем приложении
        потому что они простые и проверяют очень простой функционал.
    </p>
    <p>
        Интеграционных тестов должно быть меньше потому что они уже проверяют взаимодействие отдельных юнитов в
        нашем приложении и как они взаимодействуют друг с другом (например когда на вход одного сервиса передаём
        параметры, а он в свою очередь вызывает другие сервисы для получения выходного значения из своей функции).
    </p>
    <p>
        В случае acceptance тестов их должно быть ещё меньше потому что они самые сложные и проверяют всё приложение,
        весь функционал от начала до конца.
    </p>
    <p>
        Естественно, чем проще тест тем быстрее он запускается и быстрее отрабатывает. Чем сложнее тест, тем работает
        медленнее. Поэтому в нашем случае acceptance тесты медленее всего, а юнит-тесты быстрее всех. Чем раньше
        найдём какой-то дефект с помощью тестов тем дешевле обойдётся компании исправить эту проблему.
    </p>
    <p>
        <b>JUnit 5</b> - это один из самых распространенных Java-фреймворков, который предназначен для написания
        в основном Unit и Integration тестов. Для написания Acceptance тестов обычно используются другие тест
        фреймворки, например: <b>JBehave</b>, TestNG.
    </p>
    <p>
        JUnit 5 разбит на несколько основных под-проектов. Эти подпроекты в свою очередь разбиты на отдельные
        модули и подключаем только то, что нам необходимо:
    </p>
    <ul>
        <li>
            <b>JUnit Platform</b> - этот подпроект необходим для того чтобы была возможность запускать тесты на JVM.
            Более того, в нем есть функционал для запуска JUnit тестов на любых фреймворках (даже из консоли) и
            интеграция с такими build-инструментами как maven и gradle.
        </li>
        <li>
            <b>JUnit Jupiter</b> - этот подпроект предоставляет набор классов, которые разработчики используют для
            написания тестов. Т.е. различные API.
        </li>
        <li>
            <b>JUnit Vintage</b> - создан специально для интеграции с предыдущими версиями JUnit в случае если захотим
            использовать в своем приложении. Т.е. что-то вроде обратной совместимости с предыдущей версией JUnit 5.
        </li>
    </ul>
    <p>
        Обязательным требованием для JUnit 5 является наличие Java выше 8й версии.
    </p>
    <p>
        Наличие тестов в программе невероятно важный аспект в любом современном приложении на Java.
    </p>
</article>
</body>
</html>