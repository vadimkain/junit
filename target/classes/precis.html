<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Конспект jUnit</title>
</head>
<style>
    body {
        max-width: 80%;
        min-height: 400vh;
        margin-left: 5%;
        text-align: justify;
        font-family: Arial, sans-serif;
    }

    article {
        /*background: wheat;*/
        border-left: solid 5px #24b8ff;
        padding-left: 5%;
        margin-top: 5%;
        margin-bottom: 5%;
    }

    pre {
        /*font-size: 15px;*/
        /*font-weight: bold;*/
        background: rgba(179, 194, 245, 0.18);
    }

    code {
        font-size: 15px;
        font-weight: bold;
        background: rgba(179, 194, 245, 0.18);
    }

    li {
        margin-top: 1%;
        margin-bottom: 1%;
    }
</style>
<body>
<article>
    <h1>JUnit 5. 7. AssertJ & Hamcrest</h1>
    <p>
        Существуют дополнительные библиотеки которые можем подключать в наш проект и предоставлять более обширный
        API для наших ассертов. Это <b>AssertJ</b> & <b>Hamcrest</b>. Разберёмся с каждой из них.
    </p>
    <h2>AssertJ</h2>
    <pre>
        &lt;dependency>
            &lt;groupId>org.assertj&lt;/groupId>
            &lt;artifactId>assertj-core&lt;/artifactId>
            &lt;version>3.19.0&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
    <p>
        Переходим в <code>UserServiceTest</code> и к примеру заменим <code>assertEquals</code> на метод из assertj.
        Все AssertJ и Hamcrest имеют следующий функционал: вместо <code>assertEquals()</code>,
        <code>assertFalse()</code> и т.д. - они используют <code>asThat</code> и смысл в том, что передаём туда значение,
        которое в дальнейшем будем сравнивать (т.е. передаем сразу актуальное значение, которое будем тестировать).
        И далее, после того как передали в <code>.assertThat()</code>, мы уже можем вызывать невероятно большое
        кол-во проверок (т.е. сравнение актуального значения с каким-то ожидаемым):
    </p>
    <img src="ju-7-1.png" alt="ju-7-1" width="60%">
    <p>
        В нашем случае, когда нужно сравнивать размер - обращаемся к методу <code>.hasSize()</code>.
    </p>
    <pre>
        assertThat(users).hasSize(2);
    </pre>
    <p>
        Т.е. проверяем, что размер списка пользователей равен двум. То же самое и с Optional'ами:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }
    </pre>
    <p>
        Так же в нем удобно тестировать такие коллекции как Map. Например, сделаем метод в <code>UserService</code>,
        который возвращает <code>Map</code> пользователей, где ключом является их ID (предварительно немного
        поменяем метод <code>add()</code> в <code>UserService</code>:
    </p>
    <pre>
    package com.kainv.service;

    import com.kainv.dto.User;

    import java.util.*;

    import static java.util.function.Function.identity;
    import static java.util.stream.Collectors.toMap;

    public class UserService {

        private final List&lt;User> users = new ArrayList&lt;>();

        public List&lt;User> getAll() {
            return users;
        }

        public void add(User... users) {
            this.users.addAll(Arrays.asList(users));
        }

        public Optional&lt;User> login(String username, String password) {
            return users.stream()
                    .filter(user -> user.getUsername().equals(username))
                    .filter(user -> user.getPassword().equals(password))
                    .findFirst();
        }

        public Map&lt;Integer, User> getAllConvertedById() {
            return users.stream().collect(toMap(User::getId, identity()));
        }
    }

    </pre>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Map;
    import java.util.Optional;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertThat(users).hasSize(2);
    //        assertEquals(2, users.size());
        }

        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void usersConvertedToMapById() {
            userService.add(VADIM, PETR);

            Map&lt;Integer, User> users = userService.getAllConvertedById();


            assertAll(
                    () ->
                            // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                            assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                    () ->
                            // Проверяем Map не только на содержание, но и значений
                            assertThat(users).containsValues(VADIM, PETR)
            );

        }

        @Test
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }

    </pre>
    <p>
        Используем <code>assertAll()</code> чтобы все ассерт проверились (потому что если один ассерт провалится, то
        дальше ассерты не будут провериться).
    </p>
    <p>
        Запускаем тесты и проверяем, что наш функционал работает:
    </p>
    <img src="ju-7-2.png" alt="ju-7-2" width="30%">
</article>
<article>
    <h1>JUnit 5. 6. Test Driven Development. TDD</h1>
    <img src="ju-6-1.png" alt="ju-6-1" width="30%">
    <p>
        Суть её в том, что в процессе разработки ПО мы сначала пишем тесты, а за тем уже основной функционал, который
        покрываем этими тестами. Этот процесс можно разбить на шаги:
    </p>
    <ol>
        <li>
            Добавить тест на новую функциональность.
        </li>
        <li>
            Запустить тест. Естественно, вначале не получится запустить потому что будет ошибки компиляции. В итоге
            увидим, что тест не прошёл.
        </li>
        <li>
            Пишем код, чтобы тест прошёл
        </li>
        <li>
            Убеждаемся, что все другие тесты прошли. Это важный шаг. Здесь также ключевую роль играет <b>регрессия</b>,
            т.е. проверка того, что мы не нарушили существующий код. Это потому что пишем не только новый функционал,
            но и также изменяем его. Следственно, чтобы не нарушить ничего нас и спасают наши тесты, которые писали до
            этого. Поэтому, в четвертом шаге убеждаемся, что они (тесты) так же прошли.
        </li>
        <li>
            После чего выполняем рефакторинг кода. Это тоже один из важных шагов потому что есть хороший принцип, что
            должны после себя оставить код лучше, чем когда в первый раз видели. Так же сюда можно отнести принцип
            разбитого окна (книга программист-прагматик).
        </li>
    </ol>
    <p>
        Если рассматривать упрощённую систему TDD, то получаются три главных шага:
    </p>
    <ol>
        <li>
            <b>RED</b>
        </li>
        <li>
            <b>GREEN</b>
        </li>
        <li>
            <b>REFACTOR</b>
        </li>
    </ol>
    <h2>На примере UserService реализуем TDD</h2>
    <p>
        Создадим функцию авторизации пользователя в системе. Первым тестом будет тест на успешную авторизацию, если
        пользователь существует. Помимо этого в pom.xml подключим зависимость к lombok.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Optional;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);
            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
    <p>
        Теперь реализовываем функционал для <code>userService.login()</code>:
    </p>
    <pre>
    package com.kainv.service;

    import com.kainv.dto.User;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Optional;

    public class UserService {

        private final List&lt;User> users = new ArrayList&lt;>();

        public List&lt;User> getAll() {
            return users;
        }

        public boolean add(User user) {
            return users.add(user);
        }

        public Optional&lt;User> login(String username, String password) {
            return users.stream()
                    .filter(user -> user.getUsername().equals(username))
                    .filter(user -> user.getPassword().equals(password))
                    .findFirst();
        }
    }
    </pre>
    <p>
        Запускаем тесты и проверяем:
    </p>
    <img src="ju-6-2.png" alt="ju-6-2" width="60%">
    <p>
        Видим, что тест прошел успешно. Мы не изменяли другие методы и следовательно, маловероятно, что мы могли что-то
        повредить. Тем не менее шанс есть. Продолжаем писать функционал: на случай, если пароль неправильный.
    </p>
    <p>
        И сделаем проверку, если пользователя не существует.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Optional;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }

    </pre>
    <p>
        В итоге получается, что мы сначала подготавливаем какие-то данные, вторым шагом делаем запрос на ту функцию,
        которую проверяем и третий шаг - добавляем <code>assert</code>'ы на то, что сделали.
    </p>
    <p>
        Проверим, что все тесты проходят:
    </p>
    <img src="ju-6-3.png" alt="ju-6-3" width="25%">
</article>
<article>
    <h1>JUnit 5. 5. Запуск тестов. Launcher API</h1>
    <h2>Разберёмся как удаётся запускать тесты</h2>
    <p>
        В Java есть один единственный метод main,
        который можем запускать в языке программирования Java. Отсюда можем видеть то, как устроен JUnit 5:
    </p>
    <img src="ju-5-1.png" alt="ju-5-1" width="45%">
    <p>
        Когда пишем наши тесты - мы используем <b><i>JUnit 5 API</i></b>, который в свою очередь разбит на подпроекты.
    </p>
    <p>
        В свою очередь для выполнения тестов нам нужен <b><i>JUnit Engine</i></b>, он транзитивной зависимостью
        предоставил JUnit 5 API.
    </p>
    <p>
        В свою очередь чтобы мы могли писать на разных версиях JUnit у нас есть общий API для всех test engine'ов,
        это <b><i>JUnit Engine API</i></b>. Он также является транзитивной зависимостью когда подключаем
        <i>JUnit Engine</i>. Эта платформа называется <i>junit-platform-engine</i>.
    </p>
    <p>
        Если посмотрим на подключенные зависимости, то увидим, что как только подключили <i>junit-jupiter-engine</i>,
        то подключились <i>junit-jupiter-api</i>, который используем для написания тестов и откуда у нас есть наши
        <code>Assertions</code>, аннотации т.д.. И в то же самое время видим <i>junit-platform-engine</i>, который
        представляет API (по сути набор классов и интерфейсов), которые уже реализуются нашим
        <i>junit-jupiter-engine</i>
        для того чтобы писать на JUnit 5. Если хотим писать на JUnit 4, то там уже будет свой engine либо можем написать
        даже кастомный engine и все это так же будет работать если будем использовать <i>junit-platform-engine</i>.
    </p>
    <img src="ju-5-2.png" alt="ju-5-2" width="30%">
    <p>
        В свою очередь, для запуска тестов мы используем инструменты (<b><i>Tools</i></b>). Все они используют
        <b><i>JUnit Launcher</i></b>. Мы можем подключить эту зависимость и с помощью её вызвать соответствующие
        <i>junit-platform-engine</i> и проверить наши тесты.
    </p>
    <h2>Подключим зависимость JUnit Launcher вручную</h2>
    <pre>
        &lt;dependencies>
            &lt;dependency>
                &lt;groupId>org.junit.jupiter&lt;/groupId>
                &lt;artifactId>junit-jupiter-engine&lt;/artifactId>
                &lt;version>5.8.0-M1&lt;/version>
                &lt;scope>test&lt;/scope>
            &lt;/dependency>
            &lt;dependency>
                &lt;groupId>org.junit.platform&lt;/groupId>
                &lt;artifactId>junit-platform-launcher&lt;/artifactId>
                &lt;version>1.8.0-M1&lt;/version>
                &lt;scope>test&lt;/scope>
            &lt;/dependency>
        &lt;/dependencies>
    </pre>
    <p>
        И напишем свой класс с методом <code>main</code>, который запускает наши тесты. В методе <code>main</code>
        нужно создать <code>Launcher</code>, его объект.
    </p>
    <pre>
    package com.kainv;

    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.core.LauncherFactory;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();
        }
    }
    </pre>
    <p>
        Дефолтный интерфейс <code>Launcher</code> содержит набор методов:
    </p>
    <img src="ju-5-3.png" alt="ju-5-3" width="30%">
    <ul>
        <li>
            <b>discover</b> - нужен, для того чтобы найти те методы, которые нужно запустить (т.е. наши тестовые
            методы).
        </li>
        <li>
            <b>execute</b> - нужен, для того чтобы запустить найденные тесты.
        </li>
        <li>
            <b>registerLauncherDiscoveryListeners</b> - отслеживает события когда находим какие-то тесты.
        </li>
        <li>
            <b>registerTestExecutionListeners</b> - отслеживают выполнения каждого из этих тестов.
        </li>
    </ul>
    <p>
        Также есть и <code>DefaultLauncher</code>, который возвращается когда ничего не передаём в метод
        <code>create()</code>.
    </p>
    <p>
        Далее, можем вызвать <code>execute()</code> и выполнить тесты. В нём есть два перегруженных метода:
        <code>TestPlan</code> (он и является основным) и <code>LauncherDiscoveryRequest</code>, который в
        последующем оборачивается в <code>TestPlan</code>. В нашем случае создадим request при помощи объекта
        <code>LauncherDiscoveryRequest</code> (можно и через <code>launcher.registerLauncherDiscoveryListeners()</code>):
    </p>
    <pre>
    package com.kainv.junit;

    import org.junit.platform.engine.discovery.DiscoverySelectors;
    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.LauncherDiscoveryRequest;
    import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
    import org.junit.platform.launcher.core.LauncherFactory;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .build();
        }
    }
    </pre>
    <p>
        Теперь, в <code>launcher.execute()</code> первым параметром передаём <code>request</code> и вторым параметром
        можем передать <code>TestExecutionListener</code> (также могли бы передать в
        <code>launcher.registerTestExecutionListeners();</code>). Эти листенеры как раз нужны, для того чтобы увидеть
        результат выполнения тестов потому что метод <code>execute()</code> возвращают <code>void</code>.
    </p>
    <pre>
    package com.kainv.junit;

    import org.junit.platform.engine.discovery.DiscoverySelectors;
    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.LauncherDiscoveryRequest;
    import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
    import org.junit.platform.launcher.core.LauncherFactory;
    import org.junit.platform.launcher.listeners.SummaryGeneratingListener;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();
    //        launcher.registerTestExecutionListeners();

            SummaryGeneratingListener summaryGeneratingListener = new SummaryGeneratingListener();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .build();

            launcher.execute(request, summaryGeneratingListener);
        }
    }
    </pre>
    <p>
        Следовательно, для того чтобы посмотреть нашу статистику, то у
        <code>summaryGeneratingListener.getSummary()</code>
        после выполнения есть куча методов. Можем воспользоваться <code>.printTo()</code>, который на вход принимает
        <code>PrintWriter</code> (а значит надо использовать try-with-resources):
    </p>
    <pre>
    package com.kainv.junit;

    import org.junit.platform.engine.discovery.DiscoverySelectors;
    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.LauncherDiscoveryRequest;
    import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
    import org.junit.platform.launcher.core.LauncherFactory;
    import org.junit.platform.launcher.listeners.SummaryGeneratingListener;

    import java.io.PrintWriter;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();
    //        launcher.registerTestExecutionListeners();

            SummaryGeneratingListener summaryGeneratingListener = new SummaryGeneratingListener();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .build();

            launcher.execute(request, summaryGeneratingListener);

    //          Выводим результат тестирования
            try (PrintWriter writer = new PrintWriter(System.out)) {
                summaryGeneratingListener.getSummary().printTo(writer);
            }
        }
    }
    </pre>
    <p>
        Запустим класс и посмотрим что выведет:
    </p>
    <img src="ju-5-4.png" alt="ju-5-4" width="30%">
    <p>
        Он обнаружил два теста, два теста запустились и эти два теста завершились успешно.
    </p>
    <br>
    <p>
        Зайдём в метод <code>execute()</code>, который выполняет наши тесты. Зайдём в <code>DefaultLauncher</code>.
        Когда получаем <code>DiscoveryRequest</code> - мы на основании его билдим тестовый план и все равно в итоге
        получаем реализацию класса <code>class InternalTestPlan extends TestPlan</code> (это общий объект, чтобы
        запускать наши тесты, он содержит все по состоянию наших тестов). (10:00) И далее, в
        <code>DefaultLauncher</code> когда выполняем <code>execute()</code> (переходим по нему) и видим, что из
        нашего <code>InternalTestPlan</code> берутся все листенеры, которые билдятся в методе
        <code>buildListenerRegistryForExecution</code> и если мы не передали в метод листенеры, то возвращаются те,
        которые были зарегистрированы во время создания лаунчера. В противном случае берём общую коллекцию с нашими
        листенерами которые зарегистрировали и + те, что передали в метод <code>execute</code>. Далее создаётся
        общий комбинированный листенер, в котором запускается метод <code>testPlanExecutionStarted</code> и
        <code>testPlanExecutionFinished</code> и во время него так же вызываются события нашего листенера. Т.е. только
        через листенер мы можем посмотреть что произошло во время выполнения тестов.
    </p>
    <p>
        Так же когда выполняем метод <code>create()</code>, то передаём дефолтный <code>LauncherConfig</code> для
        создания его и создаётся <code>createDefaultLauncher()</code> в котором собираются все тестовые engine'ы.
        В нам случае используются <code>TestEngine</code>. Это как раз относится к JUnit Engine API.
    </p>
</article>
<article>
    <h1>JUnit 5. 4. Test Lifecycle</h1>
    <p>
        Познакомимся с жизненным циклом тестов.
    </p>
    <img src="ju-4-1.png" alt="ju-4-1" width="45%">
    <p>
        Когда пишем тесты в нашем <code>UserServiceTest</code>, то в этом классе у нас может быть множество таких
        тестов. Мы просто пишем методы и помечаем их аннотациями <code>@Test</code>. Но также нам часто надо
        что-то предустановить и почистить после выполнения тестов. Следственно, для этого можем написать соответствующие
        методы и пометить их аннотациями:
    </p>
    <ul>
        <li>
            <code>@BeforeEach</code> - если хотим что-то предустановить перед тестами.
        </li>
        <li>
            <code>@AfterEach</code> - если хотим почистить после каждого теста.
        </li>
    </ul>
    <p>
        Следственно, сколько будет тестов в классе, столько раз будет происходить вызов цикла <code>@BeforeEach</code>
        -> <code>@Test</code> -> <code>@AfterEach</code>. Если что-то хотим предустановить перед всеми вызовами этих
        тестов и почистить после них, то для этого есть аннотации <code>@BeforeAll</code> и <code>@AfterAll</code>.
    </p>
    <p>
        Отсюда получается жизненный цикл: сначала вызывается <code>@BeforeAll</code> перед всеми тестами ->
        далее происходит вызов всех наших тестов по циклу, при чем порядок не гарантирован. <b>Не следует</b> писать
        тесты полагаясь на вызов других тестов, наши тесты <b>должны быть</b> независимы друг от друга. Поэтому
        происходит череда вызовов тестов и перед каждым тестом и после него вызывается <code>@BeforeEach</code> и
        <code>@AfterEach</code> секция. Как только все тесты были закончены, то происходит вызов <code>@AfterAll</code>.
    </p>
    <h2>Посмотрим как это работает на практике</h2>
    <p>
        Для этого создадим ещё один <code>@Test</code> на добавление в <code>UserService</code> наших пользователей
        (заранее реализовать метод <code>add()</code> в <code>UserService</code>):
    </p>
    <pre>
    package com.kainv.service;
    
    import com.kainv.dto.User;
    
    import java.util.ArrayList;
    import java.util.List;
    
    public class UserService {
        
        private final List&lt;User> users = new ArrayList&lt;>();
        
        public List&lt;User> getAll() {
            return users;
        }
    
        public boolean add(User user) {
            return users.add(user);
        }
    }
    </pre>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            UserService userService = new UserService();
            userService.add(new User);
            userService.add(new User);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }
    }
    </pre>
    <p>
        И вызовем тесты:
    </p>
    <img src="ju-4-2.png" alt="ju-4-2" width="45%">
    <p>
        Теперь используем <code>@BeforeEach</code>. Т.е. перед тем как выполняются все наши тесты, я хочу что-то
        подготовить. Т.к. у нас два раза повторяется инициализация <code>UserService</code> в тест-методах, то значит,
        что можем эту инициализацию вынести в метод с аннотацией <code>@BeforeEach</code>.
    </p>
    <p>
        Так же создаём <code>@AfterEach</code> в котором выполняем какую-нибудь очистку. Например, данные из баз данных
        если в наших тестах делаем какие-то insert'ы и прочее для того чтобы следующий тест независил от этих данных.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.AfterEach;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {

        private UserService userService;

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(new User());
            userService.add(new User());

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }
    }
    </pre>
    <p>
        Теперь запустим и проверим что у нас получится:
    </p>
    <img src="ju-4-3.png" alt="ju-4-3" width="70%">
    <p>
        Видим, что выполнилось оба теста на каждом из которых сработали <code>@BeforeEach</code> и
        <code>@AfterEach</code>. Более того, toString отличается у нашего объекта <code>UserServiceTest</code>.
        Следовательно, у нас выходит новое <b>правило</b>, что по умолчанию каждый раз создается новый объект
        <code>UserServiceTest</code> и в нем вызываются соответсвующее методы <code>@BeforeEach</code>, выполняется
        тест и вызывается <code>@AfterEach</code>. Так будет после каждого метода. Это безопасно для нас чтобы не
        изменялось состояние наших объектов. В данном случае полей нашего класса <code>UserServiceTest</code>.
    </p>
    <p>
        Последнее это <code>@BeforeAll</code> & <code>@AfterAll</code>, где будет проходить инициализация для всех
        тестов происходить.
    </p>
    <p>
        Если попробуем запустить, то будет ошибка потому что методы <code>@BeforeAll</code> & <code>@AfterAll</code>
        должны быть <code>static</code>. По умолчанию у нас есть жизненный цикл наших тестов и можем его задавать
        через аннотацию <code>@TestInstance</code> и по умолчанию это
        <code>@TestInstance(TestInstance.Lifecycle.PER_METHOD)</code>. Т.е. каждый раз создаётся новая сущность
        <code>UserServiceTest</code> и вызывается <code>@BeforeEach</code> -> <code>@Test</code> ->
        <code>@AfterEach</code>. Следовательно, <code>@BeforeAll</code> & <code>@AfterAll</code> не могут быть не
        статическими потому что нужно как-то один раз вызвать перед тестами и один раз вызвать после всех тестов.
    </p>
    <p>
        Теперь можем запустить тесты и все будет работать:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_METHOD)
    class UserServiceTest {

        private UserService userService;

        @BeforeAll
        static void init() {
            System.out.println("Before all");
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(new User());
            userService.add(new User());

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        static void closeConnectionPool() {
            System.out.println("After all");
        }
    }
    </pre>
    <img src="ju-4-4.png" alt="ju-4-4" width="70%">
    <p>
        Но если сделаем <code>TestInstance.Lifecycle.PER_CLASS</code>, то уже нет необходимости делать
        <code>static</code> потому что тогда и так создаем лишь один объект <code>UserServiceTest</code> для
        всех тестов.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    class UserServiceTest {

        private UserService userService;

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(new User());
            userService.add(new User());

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
    <img src="ju-4-5.png" alt="ju-4-5" width="70%">
    <p>
        Видим, что теперь везде одинаковые ссылки.
    </p>
</article>
<article>
    <h1>JUnit 5. 3. Аннотация @Test. Assertions</h1>
    <p>
        Разберёмся как написать тест, общие концепции написания тестов и нейминг конвенции.
    </p>
    <p>
        Для начала, все наши тесты должны быть в директории src/test/java. Т.е. используем maven или gradle (неважно,
        поскольку используют одну структуру проектов). Например, если написали <code>UserServiceTest</code>, то это
        означает, что мы тестируем <code>UserService</code> класс и этот тест находится в той же самой директории, что
        и исходник. Используем постфикс Test потому что используем surefire-plugin, который занимается тем, что
        запускает тесты. Он отслеживает только те классы в директории test, которые заканчиваются на определенный
        постфикс или префикс. Префиксальный вариант не особо предпочтительный, зато постфиксный по умолчанию это
        <code>Test</code>, <code>Tests</code>, <code>Testcase</code>.
    </p>
    <p>
        Далее, сами классы и тесты должны в JUnit 4 должны были быть <code>public</code>, но в JUnit 5 такое не
        надо, поэтому убираем эту конструкцию с классов и тестов:
    </p>
    <pre>
    package com.kainv.junit.service;

    import org.junit.jupiter.api.Test;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void test() {
            assertTrue(false);
        }
    }
    </pre>
    <p>
        Теперь поговорим об именовании тестов. До того как появилась аннотация <code>@Test</code>, все тесты имели
        префикс Test потому что инструменты для запуска этих тестов (например surefire-plugin) отслеживал именование
        методов и по префиксу запускал те методы, которые начинаются с Test. В JUnit 5 появилась аннотация
        <code>@Test</code>, которая позволила запускать эти тесты невзирая на именование. Следовательно, теперь
        только те тесты, которые обозначены аннотацией <code>@Test</code> запускается нашим плагином. Если
        перейдём в исходники аннотации, то увидим, что её можно ставить над методами и аннотациями которые хотим
        запустить для теста:
    </p>
    <img src="ju-3-1.png" alt="ju-3-1" width="45%">
    <p>
        Мета-аннотация <code>@Testable</code> которая используется jupiter test engine просто в качестве
        мета-информации чтобы отслеживать функционал который можем запустить в качестве тестов.
    </p>
    <p>
        Создадим экземпляр класса <code>UserService</code> и вызовем метод <code>getAll()</code> (предварительно
        создав в src/java/main):
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void test() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty());
        }
    }
    </pre>
    <p>
        Мы сначала написали тест, а потом функционал. Такая методология называется <b>TTD (Test Driven
        Development)</b>.
    </p>
    <p>
        В нашем тесте проверяем, что получаем всех наших пользователей и наша коллекция будет пустая если туда
        ничего не положили. Теперь можем именовать наш <code>void test</code>. Название теста должно полностью
        отображать что у нас происходит в тесте. Так как это юнит-тест, он проверяет всего лишь маленький функционал,
        метод один единственный в одном единственном классе. В нашем случае получается:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty());
        }
    }
    </pre>
    <p>
        В именовании можем использовать как SnakeCase так и CamelCase без префиксов и постфиксов, т.к. уже стоит
        аннотация <code>@Test</code>.
    </p>
    <p>
        Запустим тест и проверим, что он работает: <code>mvn test</code>
    </p>
    <img src="ju-3-2.png" alt="ju-3-2" width="25%">
    <p>
        Видим, что тест успешно запустился и отработал.
    </p>
    <p>
        Класс <code>Assertions</code> необходим для того, чтобы проверять ожидаемое и актуальное значение, которое
        получили из функций. По сути, всегда в наших тестов подаём на вход input в "черный ящик" Input -> [box == func]
        ->
        actual output и на выходе получаем актуальные значения. В данном случае <code>assertTrue</code> принимает
        условие и если он true, то тест пройден, иначе тест проваливается. С помощью таких assert'ов происходят наши
        проверки на ожидаемые и актуальные значения. Так же можно использовать <code>assertFalse</code>:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertFalse(users.isEmpty());
        }
    }
    </pre>
    <img src="ju-3-3.png" alt="ju-3-3" width="70%">
    <p>
        Получаем Test failed и где этот тест зафейлился, в каком методе, каком классе, что ожидали получить и
        актуальное значение. Так будет всегда: подаём что-то на вход, вызываем функцию и проверяем ожидаемое и
        актуальное значение при помощи <code>assertFalse</code>. Также можем вторым параметром передавать более
        подробное описание ошибки:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertFalse(users.isEmpty(), () -> "User list should be empty");
        }
    }
    </pre>
    <img src="ju-3-4.png" alt="ju-3-4" width="70%">
    <p>
        В <code>assertEquals</code> мы можем передавать ожидаемые и актуальные данные и они должны совпасть.
    </p>
    <p>
        <code>assertThrows</code> проверяет пробрасывает ли метод какой-то exception.
    </p>
    <p>
        <code>assertAll</code> нужен когда есть несколько assert'ов в нашем методе потому что по best practice было
        бы неплохо иметь один assert в рамках одного теста потому что если зафейлится тест на строчке 13 а после него
        был ещё один assert, то мы до него даже не дойдем. Поэтому <code>assertAll</code> прекрасный вариант чтобы
        вызывать сразу несколько assert'ов и получить результат по всем из них.
    </p>
    <p>
        <code>assertArrayEquals</code> тоже самое что и <code>assertEquals</code> только проверяет массивы.
    </p>
    <p>
        И много других assert'ов. По-хорошему их все равно недостаточно поэтому так как JUnit разбит на модули и
        предполагает нам альтернативы - мы можем подключить дополнительные библиотеки для наших assert'ов (например
        AssertJ, Hamcrest).
    </p>
</article>
<article>
    <h1>JUnit 5. 2. Установка программного обеспечения</h1>
    <p>
        В качестве линковщика будем использовать maven. Подключим зависимости для JUnit 5 в pom:
    </p>
    <pre>
    &lt;dependencies>
        &lt;dependency>
          &lt;groupId>org.junit.jupiter&lt;/groupId>
          &lt;artifactId>junit-jupiter-engine&lt;/artifactId>
          &lt;version>5.8.0-M1&lt;/version>
          &lt;scope>test&lt;/scope>
        &lt;/dependency>
    &lt;/dependencies>
    </pre>
    <p>
        В test/java/com/kainv/junit/service класс UserService:
    </p>
    <pre>
package com.kainv.junit.service;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class UserService {
    @Test
    void test() {
        assertTrue(false);
    }
}
    </pre>
    <p>
        И выполним <code>mvn test</code>. И увидим проблемы:
    </p>
    <img src="ju-2-1.png" alt="ju-2-1" width="45%">
    <p>
        Во первых надо переопределить maven-compiler-plugin потому что JUnit использует версию 8 или выше. Во вторых
        надо будет переопределить surefire-plugin до новой версии.
    </p>
    <pre>
  &lt;build>
    &lt;plugins>
      &lt;plugin>
        &lt;groupId>org.apache.maven.plugins&lt;/groupId>
        &lt;artifactId>maven-compiler-plugin&lt;/artifactId>
        &lt;version>3.8.1&lt;/version>
        &lt;configuration>
            &lt;source>15&lt;/source>
            &lt;target>15&lt;/target>
        &lt;/configuration>
      &lt;/plugin>
      
      &lt;plugin>
        &lt;groupId>org.apache.maven.plugins&lt;/groupId>
        &lt;artifactId>maven-surefire-plugin&lt;/artifactId>
        &lt;version>2.22.2&lt;/version>
      &lt;/plugin>
    &lt;/plugins>
  &lt;/build>
    </pre>
    <p>
        Обновляем и выполняем <code>mvn test</code>. Проект сбилдился, но тесты не выполнились потому что наш
        тест-класс не с постфиксом <code>Test</code> (это дефолтное определение, наши тесты должны иметь определённый
        префиксы либо суффиксы). Поправим <code>UserService</code> на <code>UserServiceTest</code> и запустим:
    </p>
    <img src="ju-2-2.png" alt="ju-2-2" width="45%">
    <p>
        Видим, что тест провалился потому что у нас нет такого класса в main.
    </p>
    <p>
        Если хотим из командной строки запустить, то необходим wrapper. В командной строке вводим
        <code>mvn -N io.takari:maven:0.7.7:wrapper -Dmaven=3.6.3</code>. Получаем директорию .mvn где находится наш
        maven-wrapper. Более того, можем изменять наши пути к нужным нам установочникам в <i>.properties</i>.
        Теперь у нас есть файл <i>mvnw</i> & <i>mvnw.cmd</i> и использовать команду не <code>mvn</code>, а
        <code>./mvnw ...</code>.
    </p>
    <img src="ju-2-3.png" alt="ju-2-3" width="45%">
    <p>
        Теперь проект можно запускать как из IDE, так и из командной строки.
    </p>
</article>
<article>
    <h1>JUnit 5. 1. Введение</h1>
    <p>
        <b>Тестирование ПО</b> - это процесс испытания программы, целью которого является определить соответствие
        между <b>ожидаемым</b> поведением и <b>актуальным</b> с помощью набора тестов.
    </p>
    <img src="ju-1-1.png" alt="ju-1-1" width="45%">
    <p>
        Т.е. у нас есть какое-то приложение и, для того чтобы взаимодействовать с этим приложением - мы посылаем туда
        какие-то данные. Наше приложение обрабатывает эти данные и на выходе даёт результат input/output. И цель наших
        тестов как раз таки проверить этот актуальный результат с ожидаемым. И если они не совпадают друг с другом,
        следовательно, тесты нашли какой-то дефект в приложении. Поэтому именно такой подход всегда встречаем в
        тестировании.
    </p>
    <p>
        Тестирование необходимо не только, для того чтобы проверять новый функционал, но и для проверки
        работоспособности старого (<b>регрессионное тестирование</b>). Потому что в реальных приложениях чаще
        всего изменяется существующий функционал и велика вероятность изменения какого-то нового функционала
        при изменении другого. В этом и опасность изменений в существующем приложении. В этом случае нам помогут
        тесты.
    </p>
    <p>
        Выделяют следующие уровни тестирования:
    </p>
    <ol>
        <li>
            <b>Unit testing</b> - тестирование маленького компонента приложения (функции), т.е. этот <b>unit</b>
            должен правильно отрабатывать в изоляции от других компонентов.
            <br>
            <img src="ju-1-2.png" alt="ju-1-2" width="45%">
            <br>
            Т.е. этот юнит должен правильно отрабатывать в изоляции от других компонентов. Берём ту же самую модель,
            набор тестов, но в данном случае тестируем лишь одну какую-ту функцию в одном каком-то java-классе.
            Так же даём какой-то набор входных параметров (input) и функция возвращает какой-то результат
            (Actual output) и сверяем с ожидаемым результатом.
        </li>
        <li>
            <b>Integration testing</b> - интеграционное тестирование, тестирование несколько компонентов приложения
            (функций), т.е. как маленькие units работают вместе как один большой unit.
            <br>
            <img src="ju-1-3.png" alt="ju-1-3" width="45%">
            <br>
            Т.е. как маленькие юниты работают как один большой unit. Берём уже несколько таких функций, которые
            взаимодействуют друг с другом как одно целое и также в случае наших тестов - мы отправляем на вход
            большого юнита какие-то параметры и на выходе получаем какой-то ожидаемый результат. Мы опять же
            проверяем output актуальный с ожидаемым.
            <br>
            В java это будет выглядеть как набор классов и функций, которые просто вызывают друг друга.
        </li>
        <li>
            <b>Acceptance testing</b> - тестирование всего приложения в целом, т.е. как оно работает со стороны
            пользователя (функциональное тестирование).
            <br>
            <img src="ju-1-4.png" alt="ju-1-4" width="45%">
            <br>
            В этом случае нашим "черным ящиком" выступает всё приложение. Тестирование по сути эмулирует работу
            пользователей, которые работают с приложением. Они опять же посылают какие-то входные параметры и
            приложение отвечают им в виде output и сверяем его с ожидаемым поведением и если он не совпал, то
            тестирование выявляет какие-то дефекты приложения.
        </li>
    </ol>
    <img src="ju-1-5.png" alt="ju-1-5" width="45%">
    <p>
        Если посмотрим на эту диаграмму, то увидим, что Unit-тестов должно быть больше всего в нашем приложении
        потому что они простые и проверяют очень простой функционал.
    </p>
    <p>
        Интеграционных тестов должно быть меньше потому что они уже проверяют взаимодействие отдельных юнитов в
        нашем приложении и как они взаимодействуют друг с другом (например когда на вход одного сервиса передаём
        параметры, а он в свою очередь вызывает другие сервисы для получения выходного значения из своей функции).
    </p>
    <p>
        В случае acceptance тестов их должно быть ещё меньше потому что они самые сложные и проверяют всё приложение,
        весь функционал от начала до конца.
    </p>
    <p>
        Естественно, чем проще тест тем быстрее он запускается и быстрее отрабатывает. Чем сложнее тест, тем работает
        медленнее. Поэтому в нашем случае acceptance тесты медленее всего, а юнит-тесты быстрее всех. Чем раньше
        найдём какой-то дефект с помощью тестов тем дешевле обойдётся компании исправить эту проблему.
    </p>
    <p>
        <b>JUnit 5</b> - это один из самых распространенных Java-фреймворков, который предназначен для написания
        в основном Unit и Integration тестов. Для написания Acceptance тестов обычно используются другие тест
        фреймворки, например: <b>JBehave</b>, TestNG.
    </p>
    <p>
        JUnit 5 разбит на несколько основных под-проектов. Эти подпроекты в свою очередь разбиты на отдельные
        модули и подключаем только то, что нам необходимо:
    </p>
    <ul>
        <li>
            <b>JUnit Platform</b> - этот подпроект необходим для того чтобы была возможность запускать тесты на JVM.
            Более того, в нем есть функционал для запуска JUnit тестов на любых фреймворках (даже из консоли) и
            интеграция с такими build-инструментами как maven и gradle.
        </li>
        <li>
            <b>JUnit Jupiter</b> - этот подпроект предоставляет набор классов, которые разработчики используют для
            написания тестов. Т.е. различные API.
        </li>
        <li>
            <b>JUnit Vintage</b> - создан специально для интеграции с предыдущими версиями JUnit в случае если захотим
            использовать в своем приложении. Т.е. что-то вроде обратной совместимости с предыдущей версией JUnit 5.
        </li>
    </ul>
    <p>
        Обязательным требованием для JUnit 5 является наличие Java выше 8й версии.
    </p>
    <p>
        Наличие тестов в программе невероятно важный аспект в любом современном приложении на Java.
    </p>
</article>
</body>
</html>