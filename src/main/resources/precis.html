<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Конспект jUnit</title>
</head>
<style>
    body {
        max-width: 80%;
        min-height: 400vh;
        margin-left: 5%;
        text-align: justify;
        font-family: Arial, sans-serif;
    }

    article {
        /*background: wheat;*/
        border-left: solid 5px #24b8ff;
        padding-left: 5%;
        margin-top: 5%;
        margin-bottom: 5%;
    }

    pre {
        /*font-size: 15px;*/
        /*font-weight: bold;*/
        background: rgba(179, 194, 245, 0.18);
    }

    code {
        font-size: 15px;
        font-weight: bold;
        background: rgba(179, 194, 245, 0.18);
    }

    li {
        margin-top: 1%;
        margin-bottom: 1%;
    }
</style>
<body>
<article>
    <h1>JUnit 5. 1. Введение</h1>
    <p>
        <b>Тестирование ПО</b> - это процесс испытания программы, целью которого является определить соответствие
        между <b>ожидаемым</b> поведением и <b>актуальным</b> с помощью набора тестов.
    </p>
    <img src="ju-1-1.png" alt="ju-1-1" width="45%">
    <p>
        Т.е. у нас есть какое-то приложение и, для того чтобы взаимодействовать с этим приложением - мы посылаем туда
        какие-то данные. Наше приложение обрабатывает эти данные и на выходе даёт результат input/output. И цель наших
        тестов как раз таки проверить этот актуальный результат с ожидаемым. И если они не совпадают друг с другом,
        следовательно, тесты нашли какой-то дефект в приложении. Поэтому именно такой подход всегда встречаем в
        тестировании.
    </p>
    <p>
        Тестирование необходимо не только, для того чтобы проверять новый функционал, но и для проверки
        работоспособности старого (<b>регрессионное тестирование</b>). Потому что в реальных приложениях чаще
        всего изменяется существующий функционал и велика вероятность изменения какого-то нового функционала
        при изменении другого. В этом и опасность изменений в существующем приложении. В этом случае нам помогут
        тесты.
    </p>
    <p>
        Выделяют следующие уровни тестирования:
    </p>
    <ol>
        <li>
            <b>Unit testing</b> - тестирование маленького компонента приложения (функции), т.е. этот <b>unit</b>
            должен правильно отрабатывать в изоляции от других компонентов.
            <br>
            <img src="ju-1-2.png" alt="ju-1-2" width="45%">
            <br>
            Т.е. этот юнит должен правильно отрабатывать в изоляции от других компонентов. Берём ту же самую модель,
            набор тестов, но в данном случае тестируем лишь одну какую-ту функцию в одном каком-то java-классе.
            Так же даём какой-то набор входных параметров (input) и функция возвращает какой-то результат
            (Actual output) и сверяем с ожидаемым результатом.
        </li>
        <li>
            <b>Integration testing</b> - интеграционное тестирование, тестирование несколько компонентов приложения
            (функций), т.е. как маленькие units работают вместе как один большой unit.
            <br>
            <img src="ju-1-3.png" alt="ju-1-3" width="45%">
            <br>
            Т.е. как маленькие юниты работают как один большой unit. Берём уже несколько таких функций, которые
            взаимодействуют друг с другом как одно целое и также в случае наших тестов - мы отправляем на вход
            большого юнита какие-то параметры и на выходе получаем какой-то ожидаемый результат. Мы опять же
            проверяем output актуальный с ожидаемым.
            <br>
            В java это будет выглядеть как набор классов и функций, которые просто вызывают друг друга.
        </li>
        <li>
            <b>Acceptance testing</b> - тестирование всего приложения в целом, т.е. как оно работает со стороны
            пользователя (функциональное тестирование).
            <br>
            <img src="ju-1-4.png" alt="ju-1-4" width="45%">
            <br>
            В этом случае нашим "черным ящиком" выступает всё приложение. Тестирование по сути эмулирует работу
            пользователей, которые работают с приложением. Они опять же посылают какие-то входные параметры и
            приложение отвечают им в виде output и сверяем его с ожидаемым поведением и если он не совпал, то
            тестирование выявляет какие-то дефекты приложения.
        </li>
    </ol>
    <img src="ju-1-5.png" alt="ju-1-5" width="45%">
    <p>
        Если посмотрим на эту диаграмму, то увидим, что Unit-тестов должно быть больше всего в нашем приложении
        потому что они простые и проверяют очень простой функционал.
    </p>
    <p>
        Интеграционных тестов должно быть меньше потому что они уже проверяют взаимодействие отдельных юнитов в
        нашем приложении и как они взаимодействуют друг с другом (например когда на вход одного сервиса передаём
        параметры, а он в свою очередь вызывает другие сервисы для получения выходного значения из своей функции).
    </p>
    <p>
        В случае acceptance тестов их должно быть ещё меньше потому что они самые сложные и проверяют всё приложение,
        весь функционал от начала до конца.
    </p>
    <p>
        Естественно, чем проще тест тем быстрее он запускается и быстрее отрабатывает. Чем сложнее тест, тем работает
        медленнее. Поэтому в нашем случае acceptance тесты медленее всего, а юнит-тесты быстрее всех. Чем раньше
        найдём какой-то дефект с помощью тестов тем дешевле обойдётся компании исправить эту проблему.
    </p>
    <p>
        <b>JUnit 5</b> - это один из самых распространенных Java-фреймворков, который предназначен для написания
        в основном Unit и Integration тестов. Для написания Acceptance тестов обычно используются другие тест
        фреймворки, например: <b>JBehave</b>, TestNG.
    </p>
    <p>
        JUnit 5 разбит на несколько основных под-проектов. Эти подпроекты в свою очередь разбиты на отдельные
        модули и подключаем только то, что нам необходимо:
    </p>
    <ul>
        <li>
            <b>JUnit Platform</b> - этот подпроект необходим для того чтобы была возможность запускать тесты на JVM.
            Более того, в нем есть функционал для запуска JUnit тестов на любых фреймворках (даже из консоли) и
            интеграция с такими build-инструментами как maven и gradle.
        </li>
        <li>
            <b>JUnit Jupiter</b> - этот подпроект предоставляет набор классов, которые разработчики используют для
            написания тестов. Т.е. различные API.
        </li>
        <li>
            <b>JUnit Vintage</b> - создан специально для интеграции с предыдущими версиями JUnit в случае если захотим
            использовать в своем приложении. Т.е. что-то вроде обратной совместимости с предыдущей версией JUnit 5.
        </li>
    </ul>
    <p>
        Обязательным требованием для JUnit 5 является наличие Java выше 8й версии.
    </p>
    <p>
        Наличие тестов в программе невероятно важный аспект в любом современном приложении на Java.
    </p>
</article>
</body>
</html>