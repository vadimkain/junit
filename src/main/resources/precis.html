<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Конспект jUnit</title>
</head>
<style>
    body {
        max-width: 80%;
        min-height: 400vh;
        margin-left: 5%;
        text-align: justify;
        font-family: Arial, sans-serif;
    }

    article {
        /*background: wheat;*/
        border-left: solid 5px #24b8ff;
        padding-left: 5%;
        margin-top: 5%;
        margin-bottom: 5%;
    }

    pre {
        /*font-size: 15px;*/
        /*font-weight: bold;*/
        background: rgba(179, 194, 245, 0.18);
    }

    code {
        font-size: 15px;
        font-weight: bold;
        background: rgba(179, 194, 245, 0.18);
    }

    li {
        margin-top: 1%;
        margin-bottom: 1%;
    }
</style>
<body>
<article>
    <h1>JUnit 5. 12. Parameterized Tests</h1>
    <p>
        DI механизм принёс очень много полезных изменений. Т.е. на основании DI у нас появилась возможность использовать
        такие вещи как <b>параметризованные тесты</b>.
    </p>
    <h2>Посмотрим что такое параметризованные тесты</h2>
    <p>
        Но для этого нам необходимо подключить дополнительную зависимость:
    </p>
    <pre>
        &lt;dependency>
            &lt;groupId>org.junit.jupiter&lt;/groupId>
            &lt;artifactId>junit-jupiter-params&lt;/artifactId>
            &lt;version>5.8.0-M1&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
    <p>
        У нас появляется новая возможность писать тесты именно параметризованные тесты. Вместо того чтобы писать
        аннотацию <code>@Test</code> мы используем <code>@ParameterizedTest</code>. Далее пишем как обычный тест и
        например хотим протестировать нашу логин-функциональность большинством тест-кейсов. Т.е. когда у нас есть
        существующий юзер и несуществующий, и проблема с юзернеймом, паролем и т.д.. Т.е. этим кейсом можем закрыть
        сразу множество тест-кейсов. Для этого как раз таки подходят параметризованные тесты.
    </p>
    <p>
        И теперь, суть его в том, что мы пишем, как обычно, но в методы передаём аргументы из параметризованного теста.
        Т.е. берутся из DI-механизма. Мы просто просим предоставить нам поля <code>String username, String
        password</code>.
    </p>
    <p>
        Теперь, чтобы подставить username & password мы тоже должны предоставить какой-то класс, либо функциональность,
        которая предоставит нам эти значения с помощью DI. И для этого вместе с <code>@ParameterizedTest</code> всегда
        используется ещё одна аннотация: <code>@ArgumentsSource()</code>. Эту аннотацию можно ставить как над
        аннотацией, так и методом. Внутри себя он содержит <code>value()</code>, который представляет класс-провайдер.
        Его единственная задача: предоставить поток аргументов в наш метод. Он занимается тем, что находит наши
        аргументы (в нашем случае username и password) и это все представляется в виде аргументов. А аргумент - это
        всего лишь интерфейс, который возвращает массив объектов. Т.е. если у нас к примеру два параметра в нашем
        методе, то это массив из двух элементов.
    </p>
    <p>
        Есть уже множество готовых провайдеров. Мы можем ими воспользоваться чтобы не писать свои провайдеры:
    </p>
    <pre>
            @ParameterizedTest
    //        Для кастомных провайдеров
    //        @ArgumentsSource()
    //        Реализовывает NullArgumentsProvider
            @NullSource
    //        Реализовывает EmptyArgumentsProvider
            @EmptySource
    //        Реализовывает ValueArgumentsProvider
            @ValueSource
            void loginParameterizedTest(String username, String password) {
                userService.add(VADIM, PETR);
                Optional&lt;User> maybeUser = userService.login(username, password);
            }
    </pre>
    <p>
        Не сложно догадаться, что наши провайдеры подставляют значения в параметры. Единственное ограничение, что
        параметр должен быть один. В нашем случае username и password - это два параметра и следовательно, что для
        <code>@NullSource</code>, что и для <code>@EmptySource</code>, <code>@ValueSource</code> есть ограничения в
        один единственный параметр. Поэтому и используют их довольно редко. Но если у нас одна красивая функция с
        одним параметром, то это отличный вариант использовать <code>@NullSource</code>,<code>@EmptySource</code>,
        <code>@ValueSource</code>.
    </p>
    <p>
        Уберём один аргумент и запустим код в дебаге:
    </p>
    <pre>
            @ParameterizedTest
    //        Для кастомных провайдеров
    //        @ArgumentsSource()
    //        Реализовывает NullArgumentsProvider
            @NullSource
    //        Реализовывает EmptyArgumentsProvider
            @EmptySource
    //        @NullAndEmptySource
    //        Реализовывает ValueArgumentsProvider
    //        @ValueSource
            void loginParameterizedTest(String username) {
                userService.add(VADIM, PETR);
                Optional&lt;User> maybeUser = userService.login(username, null);
            }
    </pre>
    <img src="ju-12-1.png" alt="ju-12-1" width="60%">
    <p>
        Видим пустое значение в username потому что со String он работает так же как с массивами и коллекциями.
        <code>@ValueSource</code> работает так же только с одним параметром. Например, в данном случае если у нас только
        один параметр, то я могу предоставить <code>strings</code>:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
            @ParameterizedTest
    //        Для кастомных провайдеров
    //        @ArgumentsSource()
    //        Реализовывает NullArgumentsProvider
            @NullSource
    //        Реализовывает EmptyArgumentsProvider
            @EmptySource
    //        @NullAndEmptySource
    //        Реализовывает ValueArgumentsProvider
            @ValueSource(strings = {
                    "Vadim", "Petr"
            })
            void loginParameterizedTest(String username) {
                userService.add(VADIM, PETR);
                Optional&lt;User> maybeUser = userService.login(username, null);
            }
    </pre>
    <p>
        И если запустим дебаг, то в username сначала придёт Vadim, а потом Petr. Есть ещё один тип source'ов - это
        <code>@EnumSource</code>: используется редко - только тогда, когда у нас есть Enum вместо каких-то примитивных
        типов либо String.
    </p>
    <p>
        Что нельзя сказать про <code>@MethodSource</code> - он используется чаще всего. Мы должны предоставить ему
        название нашего метода, который примет все эти стримы аргументов. Т.е. я должен передать метод и создать его.
        Он должен быть статическим и возвращать <code>Stream&lt;Arguments></code>. Есть конечно ограничения, что
        статические методы нельзя использовать во внутренних классах, следовательно, мы должны его вынести в наш
        внешний класс. Теперь у нас нет доступа к <code>getArgumentsForLoginTest</code> методу потому что он уже
        находится не во внутреннем классе, а в каком-то другом. Но опять же, у нас есть возможность указывать любой
        статический метод в <code>@MethodSource</code>, не только внутри класса, где пишем метод. Для этого пишем
        путь к методу. Пусть состоит из полного пути класса, где состоит метод.
    </p>
    <b>UserServiceTest.java</b>
    <pre>
            @ParameterizedTest
    //        Для кастомных провайдеров
    //        @ArgumentsSource()
    //        Реализовывает NullArgumentsProvider
    //        @NullSource
    //        Реализовывает EmptyArgumentsProvider
    //        @EmptySource
    //        @NullAndEmptySource
    //        Реализовывает ValueArgumentsProvider
    //        @ValueSource(strings = {
    //                "Vadim", "Petr"
    //        })
    //        @EnumSource
            @MethodSource("com.kainv.junit.service.UserServiceTest#getArgumentsForLoginTest")
            void loginParameterizedTest(String username, String password, Optional&lt;User> user) {
                userService.add(VADIM, PETR);

                Optional&lt;User> maybeUser = userService.login(username, password);

                assertThat(maybeUser).isEqualTo(user);
            }
        }

        static Stream&lt;Arguments> getArgumentsForLoginTest() {
            return Stream.of(
                    Arguments.of("Vadim", "123", Optional.of(VADIM)),
                    Arguments.of("Petr", "123", Optional.of(PETR)),
    //                    Существующий пользователь, но неправильный пароль
                    Arguments.of("Petr", "dummy", Optional.empty()),
    //                    Пользователя не существует, а пароль существует
                    Arguments.of("dummy", "123", Optional.empty())
            );
        }
    </pre>
    <p>
        Таким образом мы можем сразу четыре кейса покрыть тестами. Запускаем наш тест и проверяем:
    </p>
    <img src="ju-12-2.png" alt="ju-12-2" width="30%">
    <p>
        Мы можем использовать обычный CSV формат и указать просто путь к нему. Для этого в тестовой директории создаём
        resources и там создаём файл <b>login-test-data.csv</b>. Т.е. именно расширение csv. Суть этого формата в том,
        что мы на каждой строке пишем какие-то значения, которые разделены любым делиметром.
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @ParameterizedTest
        @CsvFileSource(resources = "/login-test-data.csv", delimiter = ',', numLinesToSkip = 1)
        void loginParameterizedTest(String username, String password) {
            userService.add(VADIM, PETR);

            Optional&lt;User> maybeUser = userService.login(username, password);

            assertThat(maybeUser).isEqualTo(null);
        }
    </pre>
    <p>
        Если запустим этот код в дебаге, то в наши параметры передадутся все необходимые данные. Так же чтобы не
        создавать csv файл мы можем использовать аннотацию <code>@CsvSource</code>:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @ParameterizedTest
        @CsvSource({
                "Vadim,123",
                "Petr,123"
        })
        void loginParameterizedTest(String username, String password) {
            userService.add(VADIM, PETR);

            Optional&lt;User> maybeUser = userService.login(username, password);

            assertThat(maybeUser).isEqualTo(null);
        }
    </pre>
    <p>
        Так же можем именовать тесты при помощи <code>@ParameterizedTest(name = "")</code>. Внутри него есть
        разные <i>placeholder</i>'ы:
    </p>
    <pre>
        @ParameterizedTest(name = "{arguments} test")
        @MethodSource("com.kainv.junit.service.UserServiceTest#getArgumentsForLoginTest")
        void loginParameterizedTest(String username, String password, Optional&lt;User> user) {
            userService.add(VADIM, PETR);

            Optional&lt;User> maybeUser = userService.login(username, password);

            assertThat(maybeUser).isEqualTo(user);
        }
    </pre>
    <p>
        Запустим все тесты и посмотрим на результат:
    </p>
    <img src="ju-12-3.png" alt="ju-12-3" width="30%">
    <p>
        Если хотим переименовать название теста, то используем обычный <code>@DisplayName("")</code>:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @ParameterizedTest(name = "{arguments} test")
        @MethodSource("com.kainv.junit.service.UserServiceTest#getArgumentsForLoginTest")
        @DisplayName("login param test")
        void loginParameterizedTest(String username, String password, Optional&lt;User> user) {
            userService.add(VADIM, PETR);

            Optional&lt;User> maybeUser = userService.login(username, password);

            assertThat(maybeUser).isEqualTo(user);
        }
    </pre>
    <img src="ju-12-4.png" alt="ju-12-4" width="30%">
</article>
<article>
    <h1>JUnit 5. 11. Dependency Injection. DI</h1>
    <p>
        Начиная c JUnit 5 нам добавили возможность использовать такой паттерн <i>Dependency Injection</i> который
        говорит нам о том, что есть какой-то объект либо совокупность этих объектов, который предоставляет нам
        зависимости для других объектов.
    </p>
    <p>
        Например есть <code>UserServiceTest</code>, который зависит от <code>UserService</code>. Следовательно,
        <code>UserService</code> это зависимость у нашего <code>UserServiceTest</code>. Поэтому DI говорит нам о том,
        что у нас есть какой-то сторонний объект, который предоставит нам этот <code>UserService</code> если
        попросим его для нашей <code>UserServiceTest</code>.
    </p>
    <p>
        Такой подход есть во многих фреймворках. В реальной практике когда используем JUnit фреймворк вместе со
        спрингом, то используется именно DI спринга. Но если нет спринга и используем JUnit 5, то можем воспользоваться
        DI механизмом для реализации своих нужд.
    </p>
    <p>
        Например, можем создать конструктор <code>UserServiceTest</code> и в нём попросить какую-ту зависимость.
        Например <code>TestInfo</code>, т.е. я хочу чтобы какой-то объект который занимается предоставлением
        зависимостей мне дал объект с типом <code>TestInfo</code>. Более того, мы используем конструктор в своём
        <code>UserServiceTest</code>, в предыдущих версиях JUnit нельзя было делать такие конструкторы с какими-то
        параметрами потому что было обязательное требование - это то, что у тестового класса должен быть конструктор
        без параметров.
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    UserServiceTest(TestInfo testInfo) {
        System.out.println();
    }
    </pre>
    <p>
        Теперь, если запустим <code>UserServiceTest</code> в дебаге внутри конструктора, то увидим, что у нас в
        <code>testInfo</code> приходит какой-то объект, который содержит информацию:
    </p>
    <img src="ju-11-1.png" alt="ju-11-1" width="60%">
    <p>
        <code>testMethod</code> говорит о том, что мы можем использовать такой механизм DI не только в конструкторах,
        но и в тестовых методах. По сути, когда вспоминаем тему про жизненный цикл тестов, то можем использовать DI
        для всех наших основных аннотаций (<code>@BeforeAll</code> - <code>@AfterAll</code>).
    </p>
    <p>
        <b>Как работает такой механизм?</b> Есть специальный класс, который называется <code>ParameterResolver</code>
        который наследуется от <code>Extension</code>. В <code>ParameterResolver</code> есть два метода:
    </p>
    <img src="ju-11-2.png" alt="ju-11-2" width="60%">
    <p>
        <code>supportsParameter</code> вызывается вначале когда DI фреймворк определяет, подходит ли этот
        параметр нашего метода под наш параметр resolver который предоставит в последующем объект этого
        типа. Если подходит, то вызывается <code>resolveParameter</code> и мы должны вернуть этот объект.
        Если нет, то resolver параметр не возвращается.
    </p>
    <p>
        Уже есть готовые параметры resolver'ы. Как раз тот <code>TestInfo</code> который видели это
        <code>TestInfoParameterResolver</code>. Самое интересное это то, что мы можем реализовывать свои
        ParameterResolver'ы.
    </p>
    <p>
        Например, в <code>UserServiceTest</code> хотим добавить параметр-resolver который предоставит
        <code>UserService</code>. Для этого создадим пакет <b>paramresolver</b> и создадим класс
        <code>UserServiceParamResolver</code> и всё что необходимо сделать - это реализовать интерфейс
        <code>ParamResolver</code>:
    </p>
    <pre>
    package com.kainv.junit.paramresolver;

    import org.junit.jupiter.api.extension.ExtensionContext;
    import org.junit.jupiter.api.extension.ParameterContext;
    import org.junit.jupiter.api.extension.ParameterResolutionException;
    import org.junit.jupiter.api.extension.ParameterResolver;

    public class UserServiceParamResolver implements ParameterResolver {
        @Override
        public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
            return false;
        }

        @Override
        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
            return null;
        }
    }
    </pre>
    <p>
        Теперь должны эти два метода реализовать. <code>ParameterContext</code> это объект говорящий нам всю информацию
        о параметре, который мы в последующем либо за-inject'им (будем зависимы) вернув true либо нет вернув false.
        У него есть куча методов, но главный из них это <code>getParameter()</code>.
    </p>
    <pre>
    package com.kainv.junit.paramresolver;

    import com.kainv.service.UserService;
    import org.junit.jupiter.api.extension.ExtensionContext;
    import org.junit.jupiter.api.extension.ParameterContext;
    import org.junit.jupiter.api.extension.ParameterResolutionException;
    import org.junit.jupiter.api.extension.ParameterResolver;

    public class UserServiceParamResolver implements ParameterResolver {
        @Override
        public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
    //        Определим тип параметра и если он равен UserService.class, то это отличный вариант чтобы мы установили в качестве зависимости свой
            return parameterContext.getParameter().getType() == UserService.class;
        }

        @Override
        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
            return new UserService();
        }
    }
    </pre>
    <p>
        Здесь мы просто создаём через <code>new</code>, но в реальных проектах мы можем иметь более сложный механизм
        соединения этих зависимостей.
    </p>
    <p>
        Теперь в <code>UserServiceTest</code> и попросим <code>UserService</code> для нашего <code>prepare()</code>
        метода:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @BeforeEach
    void prepare(UserService userService) {
        System.out.println("Before each: " + this);
        this.userService = userService;
    }
    </pre>
    <p>
        И теперь вместо того, чтобы создавать его самим - мы просим его у нашего фреймворка. Для того чтобы использовать
        этот <code>UserServiceParamResolver</code> мы должны помочь DI механизму. Для этого используется наша
        Extension модель <code>@ExtendWith()</code> в которую передаём все классы-extension. Т.е. мы уходим от всех
        правил JUnit 4 и просто добавляем какой-то функционал к нашему тесту. Т.е. реализуем его.
    </p>
    <pre>
    @Tag("fast")
    @Tag("user")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @TestMethodOrder(MethodOrderer.DisplayName.class)
    @ExtendWith({
            UserServiceParamResolver.class
    })
    public class UserServiceTest {
    </pre>
    <p>
        Это уже как бы минус для DI механизма, что должны указывать такие ресловеры. Спринг в таком плане поможет
        решить эту проблему. Установим брекпоинты в этих местах:
    </p>
    <img src="ju-11-3.png" alt="ju-11-3" width="60%">
    <p>
        И запустим дебаг:
    </p>
    <img src="ju-11-4.png" alt="ju-11-4" width="60%">
    <p>
        Мы пришли в <code>UserServiceParamResolver</code>. Во-первых он создаётся один раз, т.е. даже если мы несколько
        раз пытаемся предоставить <code>UserService</code> объект в наших методах, то
        <code>UserServiceParamResolver</code>
        у нас один как синглтон. Это очень важно потому что мы можем к примеру реализовать какой-то функционал для
        кэширования объектов. Т.е. если не хотим каждый раз возвращать новый объект <code>UserService</code>, то можем
        создать поле в <code>UserServiceParamResolver</code> и только один раз его проинициализировать.
    </p>
    <p>
        Мы получили параметр <code>parameterContent</code> в котором видим, что сейчас требуется TestInfo. Т.к. это
        ParameterResolver для UserService, то он вернёт false и <code>resolveParameter</code> не отработает.
    </p>
    <p>
        Продолжим выполнение программы и получим:
    </p>
    <img src="ju-11-5.png" alt="ju-11-5" width="60%">
    <p>
        Теперь просим получить <code>UserService</code>. <code>parameterContext</code> вернёт true и вызовется
        <code>resolveParameter</code>:
    </p>
    <img src="ju-11-6.png" alt="ju-11-6" width="60%">
    <p>
        Мы видим все тот же <code>parameterContext</code> и <code>extensionContext</code>. В
        <code>extensionContext</code>
        хранится информация о нашем классе.
    </p>
    <h2>Что ещё есть в этом ParameterResolver'е</h2>
    <p>
        Мы можем закешировать <code>UserService</code>, но есть готовый инструмент для кеширования:
        <code>extensionContext.getStore(Namespace namespace)</code>. Namespace - это по сути ключ для нашего
        getStore. Неймспейсы можно создавать свои или использовать один глобальный:
    </p>
    <b>UserServiceParamResolver.java</b>
    <pre>
        @Override
        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
    //        Для методов которые требуют UserService мы возвращаем всегда один и тот же store:
            ExtensionContext.Store store = extensionContext.getStore(ExtensionContext.Namespace.create(UserService.class));
    //        Получаем по ключу значение
            return store.getOrComputeIfAbsent(UserService.class, it -> new UserService());
        }
    </pre>
    <p>
        <code>.create()</code> принимает массив, поэтому можем создать какой угодно сложный ключ, чтобы возвращать один
        объект или разные. В данном случае будет возвращаться один и тот же объект потому что мы получаем Namespace
        один и тот же (<code>UserService</code>) но мы к примеру можем опираться не на <code>UserService.class</code>,
        а на название метода. Тогда для каждого метода создавался бы заново наш <code>UserService</code>:
    </p>
    <b>UserServiceParamResolver.java</b>
    <pre>
        @Override
        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
    //        Для методов которые требуют UserService мы возвращаем всегда один и тот же store:
            ExtensionContext.Store store = extensionContext.getStore(Namespace.create(extensionContext.getTestMethod()));
    //        Получаем по ключу значение
            return store.getOrComputeIfAbsent(UserService.class, it -> new UserService());
        }
    </pre>
    <p>
        Лучше метод использовать в качестве ключа в том же объекте store, чтобы не создавать новый store.
    </p>
    <p>
        Таких <code>ParameterResolver</code>'ов можем создавать сколько угодно потому что <code>@ExtendWith</code>
        принимает массив таких екстеншинов. На практике они не так часто используются потому что в основном предпочитают
        использовать DI от Spring.
    </p>
</article>
<article>
    <h1>JUnit 5. 10. Tests order. Nested tests</h1>
    <p>
        Не стоит отталкиваться от того, что наши методы будут вызываться в определенном порядке потому что этот порядок
        в JUnit 5 не определён. Т.е. есть какой-то алгоритм, который запускает наши методы тестовые в каких то классах
        тестовых. Но он чисто используется для того чтобы при запуске нашего тестового класса эти методы всегда
        запускались в одном и том же порядке. Но сам порядок не гарантирован. Даже есть такой
        <i>chain gang anti-pattern</i> который как раз таки и описывает нашу ситуацию когда завязываемся на порядок
        выполнения наших тестов. Тем не менее в JUnit 5 есть возможность указать порядок. На практике лучше стараться
        не использовать это средство. За это отвечает аннотация <code>@TestMethodOrder()</code>, куда передаём
        класс, который наследуется от <code>MethodOrdered</code>. Это интерфейс, в котором есть пять реализаций:
    </p>
    <ol>
        <li>
            <b>MethodName</b> - по названию наших методов в алфавитном порядке будут вызываться все наши тесты
            устанавливаем аннотацию <code>@TestMethodOrder(MethodOrderer.MethodName.class)</code>. Запускаем и видим:
            <br>
            <img src="ju-10-2.png" alt="ju-10-2" width="30%">
        </li>
        <li>
            <b>DisplayName</b> - на самом деле это то название, которое получаем при отображении этих тестов. Не
            названия методов, а отображение названий этих методов. Для того чтобы создать DisplayName
            используем специальную аннотацию <code>@DisplayName()</code> куда передаём уже строку. Например:
            <br>
            <b>UserServiceTest.java</b>
            <pre>
    @Test
    @Order(1)
    @DisplayName("users will be empty if no user added")
    void usersEmptyIfNoUserAdded() {
        System.out.println("Test 1: " + this);

        List&lt;User> users = userService.getAll();

        MatcherAssert.assertThat(users, IsEmptyCollection.empty());
        assertTrue(users.isEmpty(), () -> "User list should be empty");
    }
            </pre>
            <p>
                И при запуске операция будет именно на <code>@DisplayName()</code>:
            </p>
            <img src="ju-10-3.png" alt="ju-10-3" width="30%">
        </li>
        <li>
            <b>OrderAnnotation</b> - используется если хотим помечать все тесты аннотацией <code>@Order</code>. Т.е.
            дополнительно каждый тест помечается аннотацией <code>@Order</code> и в ней есть один параметр обязательный:
            <code>value</code>. Т.е. нумерация от 1 до бесконечности.
            <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.hamcrest.MatcherAssert;
    import org.hamcrest.collection.IsEmptyCollection;
    import org.hamcrest.collection.IsMapContaining;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Map;
    import java.util.Optional;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.junit.jupiter.api.Assertions.*;

    @Tag("fast")
    @Tag("user")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @TestMethodOrder(MethodOrderer.OrderAnnotation.class)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        @Order(1)
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);

            List&lt;User> users = userService.getAll();

            MatcherAssert.assertThat(users, IsEmptyCollection.empty());
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        @Order(2)
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertThat(users).hasSize(2);
    //        assertEquals(2, users.size());
        }

        @Test
        @Tag("login")
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        @Tag("login")
        void throwExceptionIfUsernameOrPasswordIsNull() {
            assertAll(
                    () -> {
                        IllegalArgumentException argumentException = assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
                        assertThat(argumentException.getMessage()).isEqualTo("username or password is null");
                    },
                    () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
            );
        }

        @Test
        @Tag("login")
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void usersConvertedToMapById() {
            userService.add(VADIM, PETR);

            Map&lt;Integer, User> users = userService.getAllConvertedById();

            MatcherAssert.assertThat(users, IsMapContaining.hasKey(VADIM.getId()));

            assertAll(
                    () ->
                            // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                            assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                    () ->
                            // Проверяем Map не только на содержание, но и значений
                            assertThat(users).containsValues(VADIM, PETR)
            );
        }

        @Test
        @Tag("login")
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
            <img src="ju-10-1.png" alt="ju-10-1" width="30%">
            <p>
                Видим, что тесты в которых пометили порядок - запустились первыми по порядку. Остальные запустились в
                неопределённом порядке.
            </p>
        </li>
        <li>
            <b>Random</b> - каждый раз когда вызываем тесты в <code>UserServiceTest</code> все наши тесты будут
            выполнятся в рандомном порядке.
        </li>
    </ol>
    <p>
        Лучше <b>не использовать</b> <code>@TestMethodOrder</code> вовсе чтобы не реализовывать наш <i>chain gang
        anti-pattern</i> и избегать всяких <i>flaky tests</i> (позже будут объяснения). <code>@DisplayName</code>
        можно использовать, чтобы улучшить название наших тестовых методов когда их запускаем. Более того, для того
        чтобы пойти ещё дальше, улучшить читабельность тестов и как то их разделить.
    </p>
    <p>
        Например у нас много методов связанных с логином поэтому можем использовать т.н. nested-classes. Т.е. можем
        создать внутренний класс и туда перенести все тестовые методы, которые связаны с логином:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.hamcrest.MatcherAssert;
    import org.hamcrest.collection.IsEmptyCollection;
    import org.hamcrest.collection.IsMapContaining;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Map;
    import java.util.Optional;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.junit.jupiter.api.Assertions.*;

    @Tag("fast")
    @Tag("user")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    @TestMethodOrder(MethodOrderer.DisplayName.class)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        @Order(1)
        @DisplayName("users will be empty if no user added")
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);

            List&lt;User> users = userService.getAll();

            MatcherAssert.assertThat(users, IsEmptyCollection.empty());
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        @Order(2)
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertThat(users).hasSize(2);
    //        assertEquals(2, users.size());
        }

        @Test
        void usersConvertedToMapById() {
            userService.add(VADIM, PETR);

            Map&lt;Integer, User> users = userService.getAllConvertedById();

            MatcherAssert.assertThat(users, IsMapContaining.hasKey(VADIM.getId()));

            assertAll(
                    () ->
                            // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                            assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                    () ->
                            // Проверяем Map не только на содержание, но и значений
                            assertThat(users).containsValues(VADIM, PETR)
            );
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }

        @Nested
        @Tag("login")
        class LoginTest {
            @Test
            void loginSuccessIfUserExists() {
                userService.add(VADIM);
                userService.add(PETR);

                Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

                // Проверяем, что такой пользователь существует
                assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
                // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
                maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
            }

            @Test
            void throwExceptionIfUsernameOrPasswordIsNull() {
                assertAll(
                        () -> {
                            IllegalArgumentException argumentException = assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
                            assertThat(argumentException.getMessage()).isEqualTo("username or password is null");
                        },
                        () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
                );
            }

            @Test
            void loginFailIfPasswordIsNotCorrect() {
                userService.add(VADIM);

                Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

                assertTrue(maybeUser.isEmpty());
            }

            @Test
            void loginFailIfUserDoesNotExist() {
                userService.add(VADIM);

                Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

                assertTrue(maybeUser.isEmpty());
            }
        }
    }
    </pre>
    <p>
        Теперь нет нужды помечать аннотацией <code>@Tag("")</code> потому что можно поставить аннотацию над классом
        (все методы внутри будут автоматически с этим тэгом). Чтобы внутренний класс был как обычные тесты, мы должны
        его пометить аннотацией <code>@Nested</code>.
    </p>
    <p>
        Запускаем и проверяем:
    </p>
    <img src="ju-10-4.png" alt="ju-10-4" width="30%">
    <p>
        Более того, наш <code>@DisplayName("")</code> можно использовать над <code>@Nested</code> классами и не только.
        Следовательно, можем улучшить читабельность кода:
    </p>
    <pre>
    @Nested
    @DisplayName("test user login functionality")
    @Tag("login")
    class LoginTest {
    </pre>
    <img src="ju-10-5.png" alt="ju-10-5" width="30%">
</article>
<article>
    <h1>JUnit 5. 9. Tagging and Filtering</h1>
    <p>
        Тэги - это новая функциональность в JUnit 5, благодаря которой можем отфильтровывать наши тесты. Эта аннотация
        так и называется: <code>@Tag</code> (<code>@Tags</code> позволяет совмещать несколько тегов над одним методом
        или классом). Аннотация <code>@Tag</code> принимает одно значение - <code>values</code>.
    </p>
    <p>
        Поставим тег над тестами, которые относятся к логину:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.hamcrest.MatcherAssert;
    import org.hamcrest.collection.IsEmptyCollection;
    import org.hamcrest.collection.IsMapContaining;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Map;
    import java.util.Optional;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);

            List&lt;User> users = userService.getAll();

            MatcherAssert.assertThat(users, IsEmptyCollection.empty());
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertThat(users).hasSize(2);
    //        assertEquals(2, users.size());
        }

        @Test
        @Tag("login")
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        @Tag("login")
        void throwExceptionIfUsernameOrPasswordIsNull() {
            assertAll(
                    () -> {
                        IllegalArgumentException argumentException = assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
                        assertThat(argumentException.getMessage()).isEqualTo("username or password is null");
                    },
                    () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
            );
        }

        @Test
        @Tag("login")
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void usersConvertedToMapById() {
            userService.add(VADIM, PETR);

            Map&lt;Integer, User> users = userService.getAllConvertedById();

            MatcherAssert.assertThat(users, IsMapContaining.hasKey(VADIM.getId()));

            assertAll(
                    () ->
                            // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                            assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                    () ->
                            // Проверяем Map не только на содержание, но и значений
                            assertThat(users).containsValues(VADIM, PETR)
            );
        }

        @Test
        @Tag("login")
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
    <p>
        Такая возможность позволяет запускать только те тесты, которые помечены тэгом login. Либо например очень часто
        встречается такая возможность как запускать только те тесты, которые к примеру только unit:
    </p>
    <pre>
    @Tag("fast")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {
    </pre>
    <p>
        А интеграционные и Acceptance тесты будут помечены другими тегами. Особенно эти теги играют решающую роль для
        сложных тестов (Acceptance тестов), которые занимают довольно большую часть времени. И, следовательно, очень
        удобно запускать только те тесты, которые относятся к определенной предметной области, которую тестируем или на
        которой пишем тесты.
    </p>
    <p>
        Например, у нас есть большая функциональность на нашего пользователя. Следственно, все тесты которые помечены
        тэгом <code>@Tag("user")</code> нам нужно запускать и проверять. Это нам спасает очень большое кол-во времени
        для тестировщика:
    </p>
    <pre>
    @Tag("fast")
    @Tag("user")
    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {
    </pre>
    <h2>Разберёмся как запускать тесты по тегам</h2>
    <p>
        Если перейдём в класс <code>TestLauncher</code> где проверяли как вручную запускать тесты. Т.е. то что делают
        наши среды разработки и build-tools вроде maven'а и gradle'а под капотом. В данном случае видим, что у нас
        есть ещё один метод <code>.filters</code> и мы можем в него передавать различные фильтры. Чаще всего
        используются такие фильтры как <i>include</i> и <i>exclude</i> по префиксу или суффиксу. Так же можно
        использовать <code>TagFilter</code> в котором можно включать и исключать определенные тэги.
    </p>
    <p>
        Например, я хочу запускать только те теги, которые помечены login:
    </p>
    <pre>
    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();
    //        launcher.registerTestExecutionListeners();

            SummaryGeneratingListener summaryGeneratingListener = new SummaryGeneratingListener();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .filters(
                            TagFilter.includeTags("login")
                    )
                    .build();

            launcher.execute(request, summaryGeneratingListener);

    //        Выводим результат тестирования
            try (PrintWriter writer = new PrintWriter(System.out)) {
                summaryGeneratingListener.getSummary().printTo(writer);
            }
        }
    }
    </pre>
    <p>
        Теперь, если запустим main, то выполнятся только тесты, которые отмечены как login:
    </p>
    <img src="ju-9-1.png" alt="ju-9-1" width="30%">
    <p>
        Если обратимся к <code>.excludeTags("login")</code>, то выполнятся все которые не помечены login:
    </p>
    <b>TestLauncher.java, main()</b>
    <pre>
        LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                .request()
//                Указываем, где наш request будет искать наши тесты
//                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                .filters(
                        TagFilter.excludeTags("login")
                )
                .build();
    </pre>
    <img src="ju-9-2.png" alt="ju-9-2" width="30%">
    <p>
        Если же хотим запустить через командную строку, то в maven есть специальная JVM опции, которые позволяют
        передавать флаги через флаг -D: <code>mvn clean test -Dgroups=login</code>:
    </p>
    <img src="ju-9-3.png" alt="ju-9-3" width="60%">
    <p>
        А чтобы исключить тег, передаём флаг <code>mvn clean test -DexcludedGroups=login</code>:
    </p>
    <img src="ju-9-4.png" alt="ju-9-4" width="60%">
    <p>
        Запустим только те тесты, которые помечены тегом fast: <code>mvn clean test -Dgroups=fast</code>
    </p>
    <img src="ju-9-5.png" alt="ju-9-5" width="60%">
</article>
<article>
    <h1>JUnit 5. 8. Testing exceptions</h1>
    <p>
        Посмотрим, как можем проверить исключительные ситуации. Т.е. когда мы в наших методах пробрасываем какие-то
        исключения и мы хотим их как-то отловить и протестировать. Это должно быть ожидаемое поведение, что приложение
        пробросит исключение.
    </p>
    <p>
        Например, у нас есть функция <code>login()</code> в <code>UserService</code> и напишем тест, который проверяет,
        что этот метод пробрасывает исключение, если к примеру передали null в username или password. В таком случае
        пишем:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        void throwExceptionIfUsernameOrPasswordIsNull() {
            try {
                userService.login(null, "some password");
    //            тест не прошёл
                fail("login should throw exception on null username");
            } catch (IllegalArgumentException ex) {
    //            тест прошел, если исключение отработало
                assertTrue(true);
            }
        }
    </pre>
    <p>
        Если зайдём в исходники ассертов, то в итоге, в конечном методе увидим именно пробрасывание исключений. Т.е.,
        все ассерты - это всего лишь пробрасывание исключений. Все эти исключения - это
        <code>AssertionFailedError</code>'ы которые наследуются от <code>AssertionError</code>, а они в свою очередь
        наследуются от обычного <code>Error</code>, который наследует <code>Throwable</code>.
    </p>
    <p>
        Теперь пишем функционал, в котором метод <code>login()</code> в <code>UserService</code> будет пробрасывать
        исключение:
    </p>
    <b>UserService.java</b>
    <pre>
    public Optional&lt;User> login(String username, String password) {
        if (username == null || password == null) {
            throw new IllegalArgumentException("username or password is null");
        }
        return users.stream()
                .filter(user -> user.getUsername().equals(username))
                .filter(user -> user.getPassword().equals(password))
                .findFirst();
    }
    </pre>
    <p>
        Запускаем тест и проверяем, что он проходит:
    </p>
    <img src="ju-8-1.png" alt="ju-8-1" width="30%">
    <p>
        Если бы мы хотели проверить несколько кейсов. Например, то, что передаём не только username null, а и password,
        то нам нужно было бы использовать ещё один try-catch либо второй тест писать, что не очень удобно. Хотелось
        бы что-то вроде ассертов как делали в случае проверки нашей Map и тогда в <code>assertAll</code> запихнули бы
        сразу два тест-кейса чтобы не плодить множество тест-методов. Как раз таки для этого есть специальный
        ассерт в JUnit 5 и этот ассерт называется <code>assertThrows()</code>, в который передаём исключение, которое
        ожидаем получить:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void throwExceptionIfUsernameOrPasswordIsNull() {
        assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
    }
    </pre>
    <p>
        Более того, т.к. теперь можем проверить два тест-кейса потому что это всего лишь один ассерт, то следственно
        можем написать <code>assertAll()</code>:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void throwExceptionIfUsernameOrPasswordIsNull() {
        assertAll(
                () -> assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password")),
                () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
        );
    }
    </pre>
    <p>
        Такой функционал был в последних версиях JUnit 4, но до него мы могли проверить тип исключения только при
        помощи аннотации <code>@org.junit.Test(excepted = Exception.class)</code>. В нашем случае, если делаем
        <code>assertThrows</code>, то он ещё и возвращает исключение и можем дальше проверять его. Например, проверием
        исключение на сообщение:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void throwExceptionIfUsernameOrPasswordIsNull() {
        assertAll(
                () -> {
                    IllegalArgumentException argumentException = assertThrows(IllegalArgumentException.class, () -> userService.login(null, "some password"));
                    assertThat(argumentException.getMessage()).isEqualTo("username or password is null");
                },
                () -> assertThrows(IllegalArgumentException.class, () -> userService.login("some username", null))
        );
    }
    </pre>
</article>
<article>
    <h1>JUnit 5. 7. AssertJ & Hamcrest</h1>
    <p>
        Существуют дополнительные библиотеки которые можем подключать в наш проект и предоставлять более обширный
        API для наших ассертов. Это <b>AssertJ</b> & <b>Hamcrest</b>. Разберёмся с каждой из них.
    </p>
    <h2>AssertJ</h2>
    <pre>
        &lt;dependency>
            &lt;groupId>org.assertj&lt;/groupId>
            &lt;artifactId>assertj-core&lt;/artifactId>
            &lt;version>3.19.0&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
    <p>
        Переходим в <code>UserServiceTest</code> и к примеру заменим <code>assertEquals</code> на метод из assertj.
        Все AssertJ и Hamcrest имеют следующий функционал: вместо <code>assertEquals()</code>,
        <code>assertFalse()</code> и т.д. - они используют <code>asThat</code> и смысл в том, что передаём туда
        значение,
        которое в дальнейшем будем сравнивать (т.е. передаем сразу актуальное значение, которое будем тестировать).
        И далее, после того как передали в <code>.assertThat()</code>, мы уже можем вызывать невероятно большое
        кол-во проверок (т.е. сравнение актуального значения с каким-то ожидаемым):
    </p>
    <img src="ju-7-1.png" alt="ju-7-1" width="60%">
    <p>
        В нашем случае, когда нужно сравнивать размер - обращаемся к методу <code>.hasSize()</code>.
    </p>
    <pre>
        assertThat(users).hasSize(2);
    </pre>
    <p>
        Т.е. проверяем, что размер списка пользователей равен двум. То же самое и с Optional'ами:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }
    </pre>
    <p>
        Так же в нем удобно тестировать такие коллекции как Map. Например, сделаем метод в <code>UserService</code>,
        который возвращает <code>Map</code> пользователей, где ключом является их ID (предварительно немного
        поменяем метод <code>add()</code> в <code>UserService</code>:
    </p>
    <pre>
    package com.kainv.service;

    import com.kainv.dto.User;

    import java.util.*;

    import static java.util.function.Function.identity;
    import static java.util.stream.Collectors.toMap;

    public class UserService {

        private final List&lt;User> users = new ArrayList&lt;>();

        public List&lt;User> getAll() {
            return users;
        }

        public void add(User... users) {
            this.users.addAll(Arrays.asList(users));
        }

        public Optional&lt;User> login(String username, String password) {
            return users.stream()
                    .filter(user -> user.getUsername().equals(username))
                    .filter(user -> user.getPassword().equals(password))
                    .findFirst();
        }

        public Map&lt;Integer, User> getAllConvertedById() {
            return users.stream().collect(toMap(User::getId, identity()));
        }
    }

    </pre>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Map;
    import java.util.Optional;

    import static org.assertj.core.api.Assertions.assertThat;
    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertThat(users).hasSize(2);
    //        assertEquals(2, users.size());
        }

        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertThat(maybeUser).isPresent();
    //        assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertThat(user).isEqualTo(VADIM));
    //        maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void usersConvertedToMapById() {
            userService.add(VADIM, PETR);

            Map&lt;Integer, User> users = userService.getAllConvertedById();


            assertAll(
                    () ->
                            // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                            assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                    () ->
                            // Проверяем Map не только на содержание, но и значений
                            assertThat(users).containsValues(VADIM, PETR)
            );

        }

        @Test
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }

    </pre>
    <p>
        Используем <code>assertAll()</code> чтобы все ассерт проверились (потому что если один ассерт провалится, то
        дальше ассерты не будут провериться).
    </p>
    <p>
        Запускаем тесты и проверяем, что наш функционал работает:
    </p>
    <img src="ju-7-2.png" alt="ju-7-2" width="30%">
    <h2>Hamcrest</h2>
    <p>
        Эта библиотека была как транзитивная зависимость в JUnit 4. Подключим его и увидим, что подтягивается
        зависимость. Но в транзитивной зависимости этого недостаточно. Поэтому подключаем дополнительную зависимость:
    </p>
    <pre>
        &lt;dependency>
            &lt;groupId>junit&lt;/groupId>
            &lt;artifactId>junit&lt;/artifactId>
            &lt;version>4.13.1&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
        &lt;dependency>
            &lt;groupId>org.hamcrest&lt;/groupId>
            &lt;artifactId>hamcrest-all&lt;/artifactId>
            &lt;version>1.3&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
    <p>
        В этом случае у нас будет гораздо больше всяких matcher'ов которые можем использовать, для того чтобы работать
        с коллекциями как делаем это в assertj. Только исключим hamcrest, который пришел из junit 4:
    </p>
    <pre>
        &lt;dependency>
            &lt;groupId>junit&lt;/groupId>
            &lt;artifactId>junit&lt;/artifactId>
            &lt;version>4.13.1&lt;/version>
            &lt;scope>test&lt;/scope>
            &lt;exclusions>
                &lt;exclusion>
                    &lt;groupId>org.hamcrest&lt;/groupId>
                    &lt;artifactId>hamcrest-core&lt;/artifactId>
                &lt;/exclusion>
            &lt;/exclusions>
        &lt;/dependency>
        &lt;dependency>
            &lt;groupId>org.hamcrest&lt;/groupId>
            &lt;artifactId>hamcrest-all&lt;/artifactId>
            &lt;version>1.3&lt;/version>
            &lt;scope>test&lt;/scope>
        &lt;/dependency>
    </pre>
    <p>
        Возвращаемся в UserServiceTest и смотрим как могли бы переписать <code>usersConvertedToMapById()</code> на
        hamcrest. Он так же как и assertj использует <code>assertThat</code> функционал и в нем как и в случае
        junit передаётся два параметра: актуальное и ожидаемое:
    </p>
    <b>UserServiceTest.java</b>
    <pre>
    @Test
    void usersConvertedToMapById() {
        userService.add(VADIM, PETR);

        Map&lt;Integer, User> users = userService.getAllConvertedById();

        MatcherAssert.assertThat(users, IsMapContaining.hasKey(VADIM.getId()));

        assertAll(
                () ->
                        // В результирующей коллекции проверяем на содержание ID для Вадима и Петра
                        assertThat(users).containsKeys(VADIM.getId(), PETR.getId()),
                () ->
                        // Проверяем Map не только на содержание, но и значений
                        assertThat(users).containsValues(VADIM, PETR)
        );
    }
    </pre>
    <pre>
    @Test
    void usersEmptyIfNoUserAdded() {
        System.out.println("Test 1: " + this);

        List&lt;User> users = userService.getAll();

        MatcherAssert.assertThat(users, IsEmptyCollection.empty());
        assertTrue(users.isEmpty(), () -> "User list should be empty");
    }
    </pre>
    <p>
        Т.е. суть в том, что у нас есть множество всяких метчеров и они передаются как вторым параметром.
    </p>
</article>
<article>
    <h1>JUnit 5. 6. Test Driven Development. TDD</h1>
    <img src="ju-6-1.png" alt="ju-6-1" width="30%">
    <p>
        Суть её в том, что в процессе разработки ПО мы сначала пишем тесты, а за тем уже основной функционал, который
        покрываем этими тестами. Этот процесс можно разбить на шаги:
    </p>
    <ol>
        <li>
            Добавить тест на новую функциональность.
        </li>
        <li>
            Запустить тест. Естественно, вначале не получится запустить потому что будет ошибки компиляции. В итоге
            увидим, что тест не прошёл.
        </li>
        <li>
            Пишем код, чтобы тест прошёл
        </li>
        <li>
            Убеждаемся, что все другие тесты прошли. Это важный шаг. Здесь также ключевую роль играет <b>регрессия</b>,
            т.е. проверка того, что мы не нарушили существующий код. Это потому что пишем не только новый функционал,
            но и также изменяем его. Следственно, чтобы не нарушить ничего нас и спасают наши тесты, которые писали до
            этого. Поэтому, в четвертом шаге убеждаемся, что они (тесты) так же прошли.
        </li>
        <li>
            После чего выполняем рефакторинг кода. Это тоже один из важных шагов потому что есть хороший принцип, что
            должны после себя оставить код лучше, чем когда в первый раз видели. Так же сюда можно отнести принцип
            разбитого окна (книга программист-прагматик).
        </li>
    </ol>
    <p>
        Если рассматривать упрощённую систему TDD, то получаются три главных шага:
    </p>
    <ol>
        <li>
            <b>RED</b>
        </li>
        <li>
            <b>GREEN</b>
        </li>
        <li>
            <b>REFACTOR</b>
        </li>
    </ol>
    <h2>На примере UserService реализуем TDD</h2>
    <p>
        Создадим функцию авторизации пользователя в системе. Первым тестом будет тест на успешную авторизацию, если
        пользователь существует. Помимо этого в pom.xml подключим зависимость к lombok.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Optional;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);
            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
    <p>
        Теперь реализовываем функционал для <code>userService.login()</code>:
    </p>
    <pre>
    package com.kainv.service;

    import com.kainv.dto.User;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Optional;

    public class UserService {

        private final List&lt;User> users = new ArrayList&lt;>();

        public List&lt;User> getAll() {
            return users;
        }

        public boolean add(User user) {
            return users.add(user);
        }

        public Optional&lt;User> login(String username, String password) {
            return users.stream()
                    .filter(user -> user.getUsername().equals(username))
                    .filter(user -> user.getPassword().equals(password))
                    .findFirst();
        }
    }
    </pre>
    <p>
        Запускаем тесты и проверяем:
    </p>
    <img src="ju-6-2.png" alt="ju-6-2" width="60%">
    <p>
        Видим, что тест прошел успешно. Мы не изменяли другие методы и следовательно, маловероятно, что мы могли что-то
        повредить. Тем не менее шанс есть. Продолжаем писать функционал: на случай, если пароль неправильный.
    </p>
    <p>
        И сделаем проверку, если пользователя не существует.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;
    import java.util.Optional;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    public class UserServiceTest {

        private UserService userService;
        private static final User VADIM = User.of(1, "Vadim", "123");
        private static final User PETR = User.of(2, "Petr", "123");

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);

            userService.add(VADIM);
            userService.add(PETR);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @Test
        void loginSuccessIfUserExists() {
            userService.add(VADIM);
            userService.add(PETR);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), VADIM.getPassword());

            // Проверяем, что такой пользователь существует
            assertTrue(maybeUser.isPresent());
            // Проверяем, действительно ли это тот пользователь (первый параметр - ожидаемый, второй - фактический)
            maybeUser.ifPresent(user -> assertEquals(VADIM, user));
        }

        @Test
        void loginFailIfPasswordIsNotCorrect() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login(VADIM.getUsername(), "incorrect");

            assertTrue(maybeUser.isEmpty());
        }

        @Test
        void loginFailIfUserDoesNotExist() {
            userService.add(VADIM);

            Optional&lt;User> maybeUser = userService.login("Dima", VADIM.getPassword());

            assertTrue(maybeUser.isEmpty());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }

    </pre>
    <p>
        В итоге получается, что мы сначала подготавливаем какие-то данные, вторым шагом делаем запрос на ту функцию,
        которую проверяем и третий шаг - добавляем <code>assert</code>'ы на то, что сделали.
    </p>
    <p>
        Проверим, что все тесты проходят:
    </p>
    <img src="ju-6-3.png" alt="ju-6-3" width="25%">
</article>
<article>
    <h1>JUnit 5. 5. Запуск тестов. Launcher API</h1>
    <h2>Разберёмся как удаётся запускать тесты</h2>
    <p>
        В Java есть один единственный метод main,
        который можем запускать в языке программирования Java. Отсюда можем видеть то, как устроен JUnit 5:
    </p>
    <img src="ju-5-1.png" alt="ju-5-1" width="45%">
    <p>
        Когда пишем наши тесты - мы используем <b><i>JUnit 5 API</i></b>, который в свою очередь разбит на подпроекты.
    </p>
    <p>
        В свою очередь для выполнения тестов нам нужен <b><i>JUnit Engine</i></b>, он транзитивной зависимостью
        предоставил JUnit 5 API.
    </p>
    <p>
        В свою очередь чтобы мы могли писать на разных версиях JUnit у нас есть общий API для всех test engine'ов,
        это <b><i>JUnit Engine API</i></b>. Он также является транзитивной зависимостью когда подключаем
        <i>JUnit Engine</i>. Эта платформа называется <i>junit-platform-engine</i>.
    </p>
    <p>
        Если посмотрим на подключенные зависимости, то увидим, что как только подключили <i>junit-jupiter-engine</i>,
        то подключились <i>junit-jupiter-api</i>, который используем для написания тестов и откуда у нас есть наши
        <code>Assertions</code>, аннотации т.д.. И в то же самое время видим <i>junit-platform-engine</i>, который
        представляет API (по сути набор классов и интерфейсов), которые уже реализуются нашим
        <i>junit-jupiter-engine</i>
        для того чтобы писать на JUnit 5. Если хотим писать на JUnit 4, то там уже будет свой engine либо можем написать
        даже кастомный engine и все это так же будет работать если будем использовать <i>junit-platform-engine</i>.
    </p>
    <img src="ju-5-2.png" alt="ju-5-2" width="30%">
    <p>
        В свою очередь, для запуска тестов мы используем инструменты (<b><i>Tools</i></b>). Все они используют
        <b><i>JUnit Launcher</i></b>. Мы можем подключить эту зависимость и с помощью её вызвать соответствующие
        <i>junit-platform-engine</i> и проверить наши тесты.
    </p>
    <h2>Подключим зависимость JUnit Launcher вручную</h2>
    <pre>
        &lt;dependencies>
            &lt;dependency>
                &lt;groupId>org.junit.jupiter&lt;/groupId>
                &lt;artifactId>junit-jupiter-engine&lt;/artifactId>
                &lt;version>5.8.0-M1&lt;/version>
                &lt;scope>test&lt;/scope>
            &lt;/dependency>
            &lt;dependency>
                &lt;groupId>org.junit.platform&lt;/groupId>
                &lt;artifactId>junit-platform-launcher&lt;/artifactId>
                &lt;version>1.8.0-M1&lt;/version>
                &lt;scope>test&lt;/scope>
            &lt;/dependency>
        &lt;/dependencies>
    </pre>
    <p>
        И напишем свой класс с методом <code>main</code>, который запускает наши тесты. В методе <code>main</code>
        нужно создать <code>Launcher</code>, его объект.
    </p>
    <pre>
    package com.kainv;

    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.core.LauncherFactory;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();
        }
    }
    </pre>
    <p>
        Дефолтный интерфейс <code>Launcher</code> содержит набор методов:
    </p>
    <img src="ju-5-3.png" alt="ju-5-3" width="30%">
    <ul>
        <li>
            <b>discover</b> - нужен, для того чтобы найти те методы, которые нужно запустить (т.е. наши тестовые
            методы).
        </li>
        <li>
            <b>execute</b> - нужен, для того чтобы запустить найденные тесты.
        </li>
        <li>
            <b>registerLauncherDiscoveryListeners</b> - отслеживает события когда находим какие-то тесты.
        </li>
        <li>
            <b>registerTestExecutionListeners</b> - отслеживают выполнения каждого из этих тестов.
        </li>
    </ul>
    <p>
        Также есть и <code>DefaultLauncher</code>, который возвращается когда ничего не передаём в метод
        <code>create()</code>.
    </p>
    <p>
        Далее, можем вызвать <code>execute()</code> и выполнить тесты. В нём есть два перегруженных метода:
        <code>TestPlan</code> (он и является основным) и <code>LauncherDiscoveryRequest</code>, который в
        последующем оборачивается в <code>TestPlan</code>. В нашем случае создадим request при помощи объекта
        <code>LauncherDiscoveryRequest</code> (можно и через <code>launcher.registerLauncherDiscoveryListeners()</code>):
    </p>
    <pre>
    package com.kainv.junit;

    import org.junit.platform.engine.discovery.DiscoverySelectors;
    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.LauncherDiscoveryRequest;
    import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
    import org.junit.platform.launcher.core.LauncherFactory;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .build();
        }
    }
    </pre>
    <p>
        Теперь, в <code>launcher.execute()</code> первым параметром передаём <code>request</code> и вторым параметром
        можем передать <code>TestExecutionListener</code> (также могли бы передать в
        <code>launcher.registerTestExecutionListeners();</code>). Эти листенеры как раз нужны, для того чтобы увидеть
        результат выполнения тестов потому что метод <code>execute()</code> возвращают <code>void</code>.
    </p>
    <pre>
    package com.kainv.junit;

    import org.junit.platform.engine.discovery.DiscoverySelectors;
    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.LauncherDiscoveryRequest;
    import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
    import org.junit.platform.launcher.core.LauncherFactory;
    import org.junit.platform.launcher.listeners.SummaryGeneratingListener;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();
    //        launcher.registerTestExecutionListeners();

            SummaryGeneratingListener summaryGeneratingListener = new SummaryGeneratingListener();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .build();

            launcher.execute(request, summaryGeneratingListener);
        }
    }
    </pre>
    <p>
        Следовательно, для того чтобы посмотреть нашу статистику, то у
        <code>summaryGeneratingListener.getSummary()</code>
        после выполнения есть куча методов. Можем воспользоваться <code>.printTo()</code>, который на вход принимает
        <code>PrintWriter</code> (а значит надо использовать try-with-resources):
    </p>
    <pre>
    package com.kainv.junit;

    import org.junit.platform.engine.discovery.DiscoverySelectors;
    import org.junit.platform.launcher.Launcher;
    import org.junit.platform.launcher.LauncherDiscoveryRequest;
    import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
    import org.junit.platform.launcher.core.LauncherFactory;
    import org.junit.platform.launcher.listeners.SummaryGeneratingListener;

    import java.io.PrintWriter;

    public class TestLauncher {
        public static void main(String[] args) {
            Launcher launcher = LauncherFactory.create();

    //        launcher.registerLauncherDiscoveryListeners();
    //        launcher.registerTestExecutionListeners();

            SummaryGeneratingListener summaryGeneratingListener = new SummaryGeneratingListener();

            LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                    .request()
    //                Указываем, где наш request будет искать наши тесты
    //                .selectors(DiscoverySelectors.selectClass(UserServiceTest.class))
                    .selectors(DiscoverySelectors.selectPackage("com.kainv.junit.service"))
                    .build();

            launcher.execute(request, summaryGeneratingListener);

    //          Выводим результат тестирования
            try (PrintWriter writer = new PrintWriter(System.out)) {
                summaryGeneratingListener.getSummary().printTo(writer);
            }
        }
    }
    </pre>
    <p>
        Запустим класс и посмотрим что выведет:
    </p>
    <img src="ju-5-4.png" alt="ju-5-4" width="30%">
    <p>
        Он обнаружил два теста, два теста запустились и эти два теста завершились успешно.
    </p>
    <br>
    <p>
        Зайдём в метод <code>execute()</code>, который выполняет наши тесты. Зайдём в <code>DefaultLauncher</code>.
        Когда получаем <code>DiscoveryRequest</code> - мы на основании его билдим тестовый план и все равно в итоге
        получаем реализацию класса <code>class InternalTestPlan extends TestPlan</code> (это общий объект, чтобы
        запускать наши тесты, он содержит все по состоянию наших тестов). (10:00) И далее, в
        <code>DefaultLauncher</code> когда выполняем <code>execute()</code> (переходим по нему) и видим, что из
        нашего <code>InternalTestPlan</code> берутся все листенеры, которые билдятся в методе
        <code>buildListenerRegistryForExecution</code> и если мы не передали в метод листенеры, то возвращаются те,
        которые были зарегистрированы во время создания лаунчера. В противном случае берём общую коллекцию с нашими
        листенерами которые зарегистрировали и + те, что передали в метод <code>execute</code>. Далее создаётся
        общий комбинированный листенер, в котором запускается метод <code>testPlanExecutionStarted</code> и
        <code>testPlanExecutionFinished</code> и во время него так же вызываются события нашего листенера. Т.е. только
        через листенер мы можем посмотреть что произошло во время выполнения тестов.
    </p>
    <p>
        Так же когда выполняем метод <code>create()</code>, то передаём дефолтный <code>LauncherConfig</code> для
        создания его и создаётся <code>createDefaultLauncher()</code> в котором собираются все тестовые engine'ы.
        В нам случае используются <code>TestEngine</code>. Это как раз относится к JUnit Engine API.
    </p>
</article>
<article>
    <h1>JUnit 5. 4. Test Lifecycle</h1>
    <p>
        Познакомимся с жизненным циклом тестов.
    </p>
    <img src="ju-4-1.png" alt="ju-4-1" width="45%">
    <p>
        Когда пишем тесты в нашем <code>UserServiceTest</code>, то в этом классе у нас может быть множество таких
        тестов. Мы просто пишем методы и помечаем их аннотациями <code>@Test</code>. Но также нам часто надо
        что-то предустановить и почистить после выполнения тестов. Следственно, для этого можем написать соответствующие
        методы и пометить их аннотациями:
    </p>
    <ul>
        <li>
            <code>@BeforeEach</code> - если хотим что-то предустановить перед тестами.
        </li>
        <li>
            <code>@AfterEach</code> - если хотим почистить после каждого теста.
        </li>
    </ul>
    <p>
        Следственно, сколько будет тестов в классе, столько раз будет происходить вызов цикла <code>@BeforeEach</code>
        -> <code>@Test</code> -> <code>@AfterEach</code>. Если что-то хотим предустановить перед всеми вызовами этих
        тестов и почистить после них, то для этого есть аннотации <code>@BeforeAll</code> и <code>@AfterAll</code>.
    </p>
    <p>
        Отсюда получается жизненный цикл: сначала вызывается <code>@BeforeAll</code> перед всеми тестами ->
        далее происходит вызов всех наших тестов по циклу, при чем порядок не гарантирован. <b>Не следует</b> писать
        тесты полагаясь на вызов других тестов, наши тесты <b>должны быть</b> независимы друг от друга. Поэтому
        происходит череда вызовов тестов и перед каждым тестом и после него вызывается <code>@BeforeEach</code> и
        <code>@AfterEach</code> секция. Как только все тесты были закончены, то происходит вызов <code>@AfterAll</code>.
    </p>
    <h2>Посмотрим как это работает на практике</h2>
    <p>
        Для этого создадим ещё один <code>@Test</code> на добавление в <code>UserService</code> наших пользователей
        (заранее реализовать метод <code>add()</code> в <code>UserService</code>):
    </p>
    <pre>
    package com.kainv.service;
    
    import com.kainv.dto.User;
    
    import java.util.ArrayList;
    import java.util.List;
    
    public class UserService {
        
        private final List&lt;User> users = new ArrayList&lt;>();
        
        public List&lt;User> getAll() {
            return users;
        }
    
        public boolean add(User user) {
            return users.add(user);
        }
    }
    </pre>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            UserService userService = new UserService();
            userService.add(new User);
            userService.add(new User);

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }
    }
    </pre>
    <p>
        И вызовем тесты:
    </p>
    <img src="ju-4-2.png" alt="ju-4-2" width="45%">
    <p>
        Теперь используем <code>@BeforeEach</code>. Т.е. перед тем как выполняются все наши тесты, я хочу что-то
        подготовить. Т.к. у нас два раза повторяется инициализация <code>UserService</code> в тест-методах, то значит,
        что можем эту инициализацию вынести в метод с аннотацией <code>@BeforeEach</code>.
    </p>
    <p>
        Так же создаём <code>@AfterEach</code> в котором выполняем какую-нибудь очистку. Например, данные из баз данных
        если в наших тестах делаем какие-то insert'ы и прочее для того чтобы следующий тест независил от этих данных.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.AfterEach;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {

        private UserService userService;

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(new User());
            userService.add(new User());

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }
    }
    </pre>
    <p>
        Теперь запустим и проверим что у нас получится:
    </p>
    <img src="ju-4-3.png" alt="ju-4-3" width="70%">
    <p>
        Видим, что выполнилось оба теста на каждом из которых сработали <code>@BeforeEach</code> и
        <code>@AfterEach</code>. Более того, toString отличается у нашего объекта <code>UserServiceTest</code>.
        Следовательно, у нас выходит новое <b>правило</b>, что по умолчанию каждый раз создается новый объект
        <code>UserServiceTest</code> и в нем вызываются соответсвующее методы <code>@BeforeEach</code>, выполняется
        тест и вызывается <code>@AfterEach</code>. Так будет после каждого метода. Это безопасно для нас чтобы не
        изменялось состояние наших объектов. В данном случае полей нашего класса <code>UserServiceTest</code>.
    </p>
    <p>
        Последнее это <code>@BeforeAll</code> & <code>@AfterAll</code>, где будет проходить инициализация для всех
        тестов происходить.
    </p>
    <p>
        Если попробуем запустить, то будет ошибка потому что методы <code>@BeforeAll</code> & <code>@AfterAll</code>
        должны быть <code>static</code>. По умолчанию у нас есть жизненный цикл наших тестов и можем его задавать
        через аннотацию <code>@TestInstance</code> и по умолчанию это
        <code>@TestInstance(TestInstance.Lifecycle.PER_METHOD)</code>. Т.е. каждый раз создаётся новая сущность
        <code>UserServiceTest</code> и вызывается <code>@BeforeEach</code> -> <code>@Test</code> ->
        <code>@AfterEach</code>. Следовательно, <code>@BeforeAll</code> & <code>@AfterAll</code> не могут быть не
        статическими потому что нужно как-то один раз вызвать перед тестами и один раз вызвать после всех тестов.
    </p>
    <p>
        Теперь можем запустить тесты и все будет работать:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_METHOD)
    class UserServiceTest {

        private UserService userService;

        @BeforeAll
        static void init() {
            System.out.println("Before all");
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(new User());
            userService.add(new User());

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        static void closeConnectionPool() {
            System.out.println("After all");
        }
    }
    </pre>
    <img src="ju-4-4.png" alt="ju-4-4" width="70%">
    <p>
        Но если сделаем <code>TestInstance.Lifecycle.PER_CLASS</code>, то уже нет необходимости делать
        <code>static</code> потому что тогда и так создаем лишь один объект <code>UserServiceTest</code> для
        всех тестов.
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.*;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    @TestInstance(TestInstance.Lifecycle.PER_CLASS)
    class UserServiceTest {

        private UserService userService;

        @BeforeAll
        void init() {
            System.out.println("Before all" + this);
        }

        @BeforeEach
        void prepare() {
            System.out.println("Before each: " + this);
            userService = new UserService();
        }

        @Test
        void usersEmptyIfNoUserAdded() {
            System.out.println("Test 1: " + this);
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty(), () -> "User list should be empty");
        }

        @Test
        void usersSizeIfUserAdded() {
            System.out.println("Test 2: " + this);
            userService.add(new User());
            userService.add(new User());

            // Делаем проверку на кол-во пользователей в приложении
            List&lt;User> users = userService.getAll();

            assertEquals(2, users.size());
        }

        @AfterEach
        void deleteDataFromDatabase() {
            System.out.println("After each: " + this);
        }

        @AfterAll
        void closeConnectionPool() {
            System.out.println("After all" + this);
        }
    }
    </pre>
    <img src="ju-4-5.png" alt="ju-4-5" width="70%">
    <p>
        Видим, что теперь везде одинаковые ссылки.
    </p>
</article>
<article>
    <h1>JUnit 5. 3. Аннотация @Test. Assertions</h1>
    <p>
        Разберёмся как написать тест, общие концепции написания тестов и нейминг конвенции.
    </p>
    <p>
        Для начала, все наши тесты должны быть в директории src/test/java. Т.е. используем maven или gradle (неважно,
        поскольку используют одну структуру проектов). Например, если написали <code>UserServiceTest</code>, то это
        означает, что мы тестируем <code>UserService</code> класс и этот тест находится в той же самой директории, что
        и исходник. Используем постфикс Test потому что используем surefire-plugin, который занимается тем, что
        запускает тесты. Он отслеживает только те классы в директории test, которые заканчиваются на определенный
        постфикс или префикс. Префиксальный вариант не особо предпочтительный, зато постфиксный по умолчанию это
        <code>Test</code>, <code>Tests</code>, <code>Testcase</code>.
    </p>
    <p>
        Далее, сами классы и тесты должны в JUnit 4 должны были быть <code>public</code>, но в JUnit 5 такое не
        надо, поэтому убираем эту конструкцию с классов и тестов:
    </p>
    <pre>
    package com.kainv.junit.service;

    import org.junit.jupiter.api.Test;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void test() {
            assertTrue(false);
        }
    }
    </pre>
    <p>
        Теперь поговорим об именовании тестов. До того как появилась аннотация <code>@Test</code>, все тесты имели
        префикс Test потому что инструменты для запуска этих тестов (например surefire-plugin) отслеживал именование
        методов и по префиксу запускал те методы, которые начинаются с Test. В JUnit 5 появилась аннотация
        <code>@Test</code>, которая позволила запускать эти тесты невзирая на именование. Следовательно, теперь
        только те тесты, которые обозначены аннотацией <code>@Test</code> запускается нашим плагином. Если
        перейдём в исходники аннотации, то увидим, что её можно ставить над методами и аннотациями которые хотим
        запустить для теста:
    </p>
    <img src="ju-3-1.png" alt="ju-3-1" width="45%">
    <p>
        Мета-аннотация <code>@Testable</code> которая используется jupiter test engine просто в качестве
        мета-информации чтобы отслеживать функционал который можем запустить в качестве тестов.
    </p>
    <p>
        Создадим экземпляр класса <code>UserService</code> и вызовем метод <code>getAll()</code> (предварительно
        создав в src/java/main):
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void test() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty());
        }
    }
    </pre>
    <p>
        Мы сначала написали тест, а потом функционал. Такая методология называется <b>TTD (Test Driven
        Development)</b>.
    </p>
    <p>
        В нашем тесте проверяем, что получаем всех наших пользователей и наша коллекция будет пустая если туда
        ничего не положили. Теперь можем именовать наш <code>void test</code>. Название теста должно полностью
        отображать что у нас происходит в тесте. Так как это юнит-тест, он проверяет всего лишь маленький функционал,
        метод один единственный в одном единственном классе. В нашем случае получается:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertTrue(users.isEmpty());
        }
    }
    </pre>
    <p>
        В именовании можем использовать как SnakeCase так и CamelCase без префиксов и постфиксов, т.к. уже стоит
        аннотация <code>@Test</code>.
    </p>
    <p>
        Запустим тест и проверим, что он работает: <code>mvn test</code>
    </p>
    <img src="ju-3-2.png" alt="ju-3-2" width="25%">
    <p>
        Видим, что тест успешно запустился и отработал.
    </p>
    <p>
        Класс <code>Assertions</code> необходим для того, чтобы проверять ожидаемое и актуальное значение, которое
        получили из функций. По сути, всегда в наших тестов подаём на вход input в "черный ящик" Input -> [box == func]
        ->
        actual output и на выходе получаем актуальные значения. В данном случае <code>assertTrue</code> принимает
        условие и если он true, то тест пройден, иначе тест проваливается. С помощью таких assert'ов происходят наши
        проверки на ожидаемые и актуальные значения. Так же можно использовать <code>assertFalse</code>:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertFalse(users.isEmpty());
        }
    }
    </pre>
    <img src="ju-3-3.png" alt="ju-3-3" width="70%">
    <p>
        Получаем Test failed и где этот тест зафейлился, в каком методе, каком классе, что ожидали получить и
        актуальное значение. Так будет всегда: подаём что-то на вход, вызываем функцию и проверяем ожидаемое и
        актуальное значение при помощи <code>assertFalse</code>. Также можем вторым параметром передавать более
        подробное описание ошибки:
    </p>
    <pre>
    package com.kainv.junit.service;

    import com.kainv.dto.User;
    import com.kainv.service.UserService;
    import org.junit.jupiter.api.Test;

    import java.util.List;

    import static org.junit.jupiter.api.Assertions.*;

    class UserServiceTest {
        @Test
        void usersEmptyIfNoUserAdded() {
            UserService userService = new UserService();
            List&lt;User> users = userService.getAll();
            assertFalse(users.isEmpty(), () -> "User list should be empty");
        }
    }
    </pre>
    <img src="ju-3-4.png" alt="ju-3-4" width="70%">
    <p>
        В <code>assertEquals</code> мы можем передавать ожидаемые и актуальные данные и они должны совпасть.
    </p>
    <p>
        <code>assertThrows</code> проверяет пробрасывает ли метод какой-то exception.
    </p>
    <p>
        <code>assertAll</code> нужен когда есть несколько assert'ов в нашем методе потому что по best practice было
        бы неплохо иметь один assert в рамках одного теста потому что если зафейлится тест на строчке 13 а после него
        был ещё один assert, то мы до него даже не дойдем. Поэтому <code>assertAll</code> прекрасный вариант чтобы
        вызывать сразу несколько assert'ов и получить результат по всем из них.
    </p>
    <p>
        <code>assertArrayEquals</code> тоже самое что и <code>assertEquals</code> только проверяет массивы.
    </p>
    <p>
        И много других assert'ов. По-хорошему их все равно недостаточно поэтому так как JUnit разбит на модули и
        предполагает нам альтернативы - мы можем подключить дополнительные библиотеки для наших assert'ов (например
        AssertJ, Hamcrest).
    </p>
</article>
<article>
    <h1>JUnit 5. 2. Установка программного обеспечения</h1>
    <p>
        В качестве линковщика будем использовать maven. Подключим зависимости для JUnit 5 в pom:
    </p>
    <pre>
    &lt;dependencies>
        &lt;dependency>
          &lt;groupId>org.junit.jupiter&lt;/groupId>
          &lt;artifactId>junit-jupiter-engine&lt;/artifactId>
          &lt;version>5.8.0-M1&lt;/version>
          &lt;scope>test&lt;/scope>
        &lt;/dependency>
    &lt;/dependencies>
    </pre>
    <p>
        В test/java/com/kainv/junit/service класс UserService:
    </p>
    <pre>
package com.kainv.junit.service;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class UserService {
    @Test
    void test() {
        assertTrue(false);
    }
}
    </pre>
    <p>
        И выполним <code>mvn test</code>. И увидим проблемы:
    </p>
    <img src="ju-2-1.png" alt="ju-2-1" width="45%">
    <p>
        Во первых надо переопределить maven-compiler-plugin потому что JUnit использует версию 8 или выше. Во вторых
        надо будет переопределить surefire-plugin до новой версии.
    </p>
    <pre>
  &lt;build>
    &lt;plugins>
      &lt;plugin>
        &lt;groupId>org.apache.maven.plugins&lt;/groupId>
        &lt;artifactId>maven-compiler-plugin&lt;/artifactId>
        &lt;version>3.8.1&lt;/version>
        &lt;configuration>
            &lt;source>15&lt;/source>
            &lt;target>15&lt;/target>
        &lt;/configuration>
      &lt;/plugin>
      
      &lt;plugin>
        &lt;groupId>org.apache.maven.plugins&lt;/groupId>
        &lt;artifactId>maven-surefire-plugin&lt;/artifactId>
        &lt;version>2.22.2&lt;/version>
      &lt;/plugin>
    &lt;/plugins>
  &lt;/build>
    </pre>
    <p>
        Обновляем и выполняем <code>mvn test</code>. Проект сбилдился, но тесты не выполнились потому что наш
        тест-класс не с постфиксом <code>Test</code> (это дефолтное определение, наши тесты должны иметь определённый
        префиксы либо суффиксы). Поправим <code>UserService</code> на <code>UserServiceTest</code> и запустим:
    </p>
    <img src="ju-2-2.png" alt="ju-2-2" width="45%">
    <p>
        Видим, что тест провалился потому что у нас нет такого класса в main.
    </p>
    <p>
        Если хотим из командной строки запустить, то необходим wrapper. В командной строке вводим
        <code>mvn -N io.takari:maven:0.7.7:wrapper -Dmaven=3.6.3</code>. Получаем директорию .mvn где находится наш
        maven-wrapper. Более того, можем изменять наши пути к нужным нам установочникам в <i>.properties</i>.
        Теперь у нас есть файл <i>mvnw</i> & <i>mvnw.cmd</i> и использовать команду не <code>mvn</code>, а
        <code>./mvnw ...</code>.
    </p>
    <img src="ju-2-3.png" alt="ju-2-3" width="45%">
    <p>
        Теперь проект можно запускать как из IDE, так и из командной строки.
    </p>
</article>
<article>
    <h1>JUnit 5. 1. Введение</h1>
    <p>
        <b>Тестирование ПО</b> - это процесс испытания программы, целью которого является определить соответствие
        между <b>ожидаемым</b> поведением и <b>актуальным</b> с помощью набора тестов.
    </p>
    <img src="ju-1-1.png" alt="ju-1-1" width="45%">
    <p>
        Т.е. у нас есть какое-то приложение и, для того чтобы взаимодействовать с этим приложением - мы посылаем туда
        какие-то данные. Наше приложение обрабатывает эти данные и на выходе даёт результат input/output. И цель наших
        тестов как раз таки проверить этот актуальный результат с ожидаемым. И если они не совпадают друг с другом,
        следовательно, тесты нашли какой-то дефект в приложении. Поэтому именно такой подход всегда встречаем в
        тестировании.
    </p>
    <p>
        Тестирование необходимо не только, для того чтобы проверять новый функционал, но и для проверки
        работоспособности старого (<b>регрессионное тестирование</b>). Потому что в реальных приложениях чаще
        всего изменяется существующий функционал и велика вероятность изменения какого-то нового функционала
        при изменении другого. В этом и опасность изменений в существующем приложении. В этом случае нам помогут
        тесты.
    </p>
    <p>
        Выделяют следующие уровни тестирования:
    </p>
    <ol>
        <li>
            <b>Unit testing</b> - тестирование маленького компонента приложения (функции), т.е. этот <b>unit</b>
            должен правильно отрабатывать в изоляции от других компонентов.
            <br>
            <img src="ju-1-2.png" alt="ju-1-2" width="45%">
            <br>
            Т.е. этот юнит должен правильно отрабатывать в изоляции от других компонентов. Берём ту же самую модель,
            набор тестов, но в данном случае тестируем лишь одну какую-ту функцию в одном каком-то java-классе.
            Так же даём какой-то набор входных параметров (input) и функция возвращает какой-то результат
            (Actual output) и сверяем с ожидаемым результатом.
        </li>
        <li>
            <b>Integration testing</b> - интеграционное тестирование, тестирование несколько компонентов приложения
            (функций), т.е. как маленькие units работают вместе как один большой unit.
            <br>
            <img src="ju-1-3.png" alt="ju-1-3" width="45%">
            <br>
            Т.е. как маленькие юниты работают как один большой unit. Берём уже несколько таких функций, которые
            взаимодействуют друг с другом как одно целое и также в случае наших тестов - мы отправляем на вход
            большого юнита какие-то параметры и на выходе получаем какой-то ожидаемый результат. Мы опять же
            проверяем output актуальный с ожидаемым.
            <br>
            В java это будет выглядеть как набор классов и функций, которые просто вызывают друг друга.
        </li>
        <li>
            <b>Acceptance testing</b> - тестирование всего приложения в целом, т.е. как оно работает со стороны
            пользователя (функциональное тестирование).
            <br>
            <img src="ju-1-4.png" alt="ju-1-4" width="45%">
            <br>
            В этом случае нашим "черным ящиком" выступает всё приложение. Тестирование по сути эмулирует работу
            пользователей, которые работают с приложением. Они опять же посылают какие-то входные параметры и
            приложение отвечают им в виде output и сверяем его с ожидаемым поведением и если он не совпал, то
            тестирование выявляет какие-то дефекты приложения.
        </li>
    </ol>
    <img src="ju-1-5.png" alt="ju-1-5" width="45%">
    <p>
        Если посмотрим на эту диаграмму, то увидим, что Unit-тестов должно быть больше всего в нашем приложении
        потому что они простые и проверяют очень простой функционал.
    </p>
    <p>
        Интеграционных тестов должно быть меньше потому что они уже проверяют взаимодействие отдельных юнитов в
        нашем приложении и как они взаимодействуют друг с другом (например когда на вход одного сервиса передаём
        параметры, а он в свою очередь вызывает другие сервисы для получения выходного значения из своей функции).
    </p>
    <p>
        В случае acceptance тестов их должно быть ещё меньше потому что они самые сложные и проверяют всё приложение,
        весь функционал от начала до конца.
    </p>
    <p>
        Естественно, чем проще тест тем быстрее он запускается и быстрее отрабатывает. Чем сложнее тест, тем работает
        медленнее. Поэтому в нашем случае acceptance тесты медленее всего, а юнит-тесты быстрее всех. Чем раньше
        найдём какой-то дефект с помощью тестов тем дешевле обойдётся компании исправить эту проблему.
    </p>
    <p>
        <b>JUnit 5</b> - это один из самых распространенных Java-фреймворков, который предназначен для написания
        в основном Unit и Integration тестов. Для написания Acceptance тестов обычно используются другие тест
        фреймворки, например: <b>JBehave</b>, TestNG.
    </p>
    <p>
        JUnit 5 разбит на несколько основных под-проектов. Эти подпроекты в свою очередь разбиты на отдельные
        модули и подключаем только то, что нам необходимо:
    </p>
    <ul>
        <li>
            <b>JUnit Platform</b> - этот подпроект необходим для того чтобы была возможность запускать тесты на JVM.
            Более того, в нем есть функционал для запуска JUnit тестов на любых фреймворках (даже из консоли) и
            интеграция с такими build-инструментами как maven и gradle.
        </li>
        <li>
            <b>JUnit Jupiter</b> - этот подпроект предоставляет набор классов, которые разработчики используют для
            написания тестов. Т.е. различные API.
        </li>
        <li>
            <b>JUnit Vintage</b> - создан специально для интеграции с предыдущими версиями JUnit в случае если захотим
            использовать в своем приложении. Т.е. что-то вроде обратной совместимости с предыдущей версией JUnit 5.
        </li>
    </ul>
    <p>
        Обязательным требованием для JUnit 5 является наличие Java выше 8й версии.
    </p>
    <p>
        Наличие тестов в программе невероятно важный аспект в любом современном приложении на Java.
    </p>
</article>
</body>
</html>